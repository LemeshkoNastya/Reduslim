/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/components/phone-country.js":
/*!********************************************!*\
  !*** ./src/js/components/phone-country.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var intl_tel_input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! intl-tel-input */ \"./node_modules/intl-tel-input/index.js\");\n/* harmony import */ var intl_tel_input__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(intl_tel_input__WEBPACK_IMPORTED_MODULE_0__);\n // Magic string\n\nconst idFlag = '#flag';\nconst idInput = '#tel';\nconst classIso = '.form__iso';\nconst countryDefault = 'ru';\nconst urlPlugin = 'https://cdnjs.cloudflare.com/ajax/libs/intl-tel-input/11.0.4/js/utils.js'; // Variables\n\nconst flag = document.querySelector(idFlag);\nconst input = document.querySelector(idInput);\nconst isoForm = document.querySelector(classIso); // Initialization plugin\n\nconst test = intl_tel_input__WEBPACK_IMPORTED_MODULE_0___default()(flag, {\n  initialCountry: countryDefault,\n  utilsScript: urlPlugin\n}); // Event\n\nflag.addEventListener('countrychange', () => {\n  input.placeholder = flag.placeholder;\n  isoForm.innerHTML = test.getSelectedCountryData().iso2;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvY29tcG9uZW50cy9waG9uZS1jb3VudHJ5LmpzLmpzIiwibWFwcGluZ3MiOiI7OztDQUVBOztBQUNBLE1BQU1DLE1BQU0sR0FBRyxPQUFmO0FBQ0EsTUFBTUMsT0FBTyxHQUFHLE1BQWhCO0FBQ0EsTUFBTUMsUUFBUSxHQUFHLFlBQWpCO0FBQ0EsTUFBTUMsY0FBYyxHQUFHLElBQXZCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLDBFQUFsQixFQUVBOztBQUNBLE1BQU1DLElBQUksR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCUCxNQUF2QixDQUFiO0FBQ0EsTUFBTVEsS0FBSyxHQUFHRixRQUFRLENBQUNDLGFBQVQsQ0FBdUJOLE9BQXZCLENBQWQ7QUFDQSxNQUFNUSxPQUFPLEdBQUdILFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QkwsUUFBdkIsQ0FBaEIsRUFFQTs7QUFDQSxNQUFNUSxJQUFJLEdBQUdYLHFEQUFZLENBQUNNLElBQUQsRUFBTztBQUM1Qk0sRUFBQUEsY0FBYyxFQUFFUixjQURZO0FBRTVCUyxFQUFBQSxXQUFXLEVBQUVSO0FBRmUsQ0FBUCxDQUF6QixFQUtBOztBQUNBQyxJQUFJLENBQUNRLGdCQUFMLENBQXNCLGVBQXRCLEVBQXVDLE1BQU07QUFDekNMLEVBQUFBLEtBQUssQ0FBQ00sV0FBTixHQUFvQlQsSUFBSSxDQUFDUyxXQUF6QjtBQUNBTCxFQUFBQSxPQUFPLENBQUNNLFNBQVIsR0FBb0JMLElBQUksQ0FBQ00sc0JBQUwsR0FBOEJDLElBQWxEO0FBQ0gsQ0FIRCIsInNvdXJjZXMiOlsid2VicGFjazovL1RQYXNzLy4vc3JjL2pzL2NvbXBvbmVudHMvcGhvbmUtY291bnRyeS5qcz81YWQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpbnRsVGVsSW5wdXQgZnJvbSAnaW50bC10ZWwtaW5wdXQnO1xyXG5cclxuLy8gTWFnaWMgc3RyaW5nXHJcbmNvbnN0IGlkRmxhZyA9ICcjZmxhZyc7XHJcbmNvbnN0IGlkSW5wdXQgPSAnI3RlbCc7XHJcbmNvbnN0IGNsYXNzSXNvID0gJy5mb3JtX19pc28nO1xyXG5jb25zdCBjb3VudHJ5RGVmYXVsdCA9ICdydSc7XHJcbmNvbnN0IHVybFBsdWdpbiA9ICdodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9pbnRsLXRlbC1pbnB1dC8xMS4wLjQvanMvdXRpbHMuanMnO1xyXG5cclxuLy8gVmFyaWFibGVzXHJcbmNvbnN0IGZsYWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGlkRmxhZyk7XHJcbmNvbnN0IGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpZElucHV0KTtcclxuY29uc3QgaXNvRm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY2xhc3NJc28pO1xyXG5cclxuLy8gSW5pdGlhbGl6YXRpb24gcGx1Z2luXHJcbmNvbnN0IHRlc3QgPSBpbnRsVGVsSW5wdXQoZmxhZywge1xyXG4gICAgaW5pdGlhbENvdW50cnk6IGNvdW50cnlEZWZhdWx0LFxyXG4gICAgdXRpbHNTY3JpcHQ6IHVybFBsdWdpbixcclxufSk7XHJcblxyXG4vLyBFdmVudFxyXG5mbGFnLmFkZEV2ZW50TGlzdGVuZXIoJ2NvdW50cnljaGFuZ2UnLCAoKSA9PiB7XHJcbiAgICBpbnB1dC5wbGFjZWhvbGRlciA9IGZsYWcucGxhY2Vob2xkZXI7XHJcbiAgICBpc29Gb3JtLmlubmVySFRNTCA9IHRlc3QuZ2V0U2VsZWN0ZWRDb3VudHJ5RGF0YSgpLmlzbzI7XHJcbn0pOyJdLCJuYW1lcyI6WyJpbnRsVGVsSW5wdXQiLCJpZEZsYWciLCJpZElucHV0IiwiY2xhc3NJc28iLCJjb3VudHJ5RGVmYXVsdCIsInVybFBsdWdpbiIsImZsYWciLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJpbnB1dCIsImlzb0Zvcm0iLCJ0ZXN0IiwiaW5pdGlhbENvdW50cnkiLCJ1dGlsc1NjcmlwdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwbGFjZWhvbGRlciIsImlubmVySFRNTCIsImdldFNlbGVjdGVkQ291bnRyeURhdGEiLCJpc28yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/components/phone-country.js\n");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/main.scss */ \"./src/styles/main.scss\");\n/* harmony import */ var _components_phone_country__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/phone-country */ \"./src/js/components/phone-country.js\");\n// Styles\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvanMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL1RQYXNzLy4vc3JjL2pzL2luZGV4LmpzPzdiYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU3R5bGVzXHJcbmltcG9ydCAnLi4vc3R5bGVzL21haW4uc2Nzcyc7XHJcblxyXG5pbXBvcnQgJy4vY29tcG9uZW50cy9waG9uZS1jb3VudHJ5JzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/index.js\n");

/***/ }),

/***/ "./node_modules/intl-tel-input/build/js/intlTelInput.js":
/*!**************************************************************!*\
  !*** ./node_modules/intl-tel-input/build/js/intlTelInput.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/*\n * International Telephone Input v17.0.13\n * https://github.com/jackocnr/intl-tel-input.git\n * Licensed under the MIT license\n */\n\n// wrap in UMD\n(function(factory) {\n    if ( true && module.exports) module.exports = factory(); else window.intlTelInput = factory();\n})(function(undefined) {\n    \"use strict\";\n    return function() {\n        // Array of country objects for the flag dropdown.\n        // Here is the criteria for the plugin to support a given country/territory\n        // - It has an iso2 code: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\n        // - It has it's own country calling code (it is not a sub-region of another country): https://en.wikipedia.org/wiki/List_of_country_calling_codes\n        // - It has a flag in the region-flags project: https://github.com/behdad/region-flags/tree/gh-pages/png\n        // - It is supported by libphonenumber (it must be listed on this page): https://github.com/googlei18n/libphonenumber/blob/master/resources/ShortNumberMetadata.xml\n        // Each country array has the following information:\n        // [\n        //    Country name,\n        //    iso2 code,\n        //    International dial code,\n        //    Order (if >1 country with same dial code),\n        //    Area codes\n        // ]\n        var allCountries = [ [ \"Afghanistan (‫افغانستان‬‎)\", \"af\", \"93\" ], [ \"Albania (Shqipëri)\", \"al\", \"355\" ], [ \"Algeria (‫الجزائر‬‎)\", \"dz\", \"213\" ], [ \"American Samoa\", \"as\", \"1\", 5, [ \"684\" ] ], [ \"Andorra\", \"ad\", \"376\" ], [ \"Angola\", \"ao\", \"244\" ], [ \"Anguilla\", \"ai\", \"1\", 6, [ \"264\" ] ], [ \"Antigua and Barbuda\", \"ag\", \"1\", 7, [ \"268\" ] ], [ \"Argentina\", \"ar\", \"54\" ], [ \"Armenia (Հայաստան)\", \"am\", \"374\" ], [ \"Aruba\", \"aw\", \"297\" ], [ \"Ascension Island\", \"ac\", \"247\" ], [ \"Australia\", \"au\", \"61\", 0 ], [ \"Austria (Österreich)\", \"at\", \"43\" ], [ \"Azerbaijan (Azərbaycan)\", \"az\", \"994\" ], [ \"Bahamas\", \"bs\", \"1\", 8, [ \"242\" ] ], [ \"Bahrain (‫البحرين‬‎)\", \"bh\", \"973\" ], [ \"Bangladesh (বাংলাদেশ)\", \"bd\", \"880\" ], [ \"Barbados\", \"bb\", \"1\", 9, [ \"246\" ] ], [ \"Belarus (Беларусь)\", \"by\", \"375\" ], [ \"Belgium (België)\", \"be\", \"32\" ], [ \"Belize\", \"bz\", \"501\" ], [ \"Benin (Bénin)\", \"bj\", \"229\" ], [ \"Bermuda\", \"bm\", \"1\", 10, [ \"441\" ] ], [ \"Bhutan (འབྲུག)\", \"bt\", \"975\" ], [ \"Bolivia\", \"bo\", \"591\" ], [ \"Bosnia and Herzegovina (Босна и Херцеговина)\", \"ba\", \"387\" ], [ \"Botswana\", \"bw\", \"267\" ], [ \"Brazil (Brasil)\", \"br\", \"55\" ], [ \"British Indian Ocean Territory\", \"io\", \"246\" ], [ \"British Virgin Islands\", \"vg\", \"1\", 11, [ \"284\" ] ], [ \"Brunei\", \"bn\", \"673\" ], [ \"Bulgaria (България)\", \"bg\", \"359\" ], [ \"Burkina Faso\", \"bf\", \"226\" ], [ \"Burundi (Uburundi)\", \"bi\", \"257\" ], [ \"Cambodia (កម្ពុជា)\", \"kh\", \"855\" ], [ \"Cameroon (Cameroun)\", \"cm\", \"237\" ], [ \"Canada\", \"ca\", \"1\", 1, [ \"204\", \"226\", \"236\", \"249\", \"250\", \"289\", \"306\", \"343\", \"365\", \"387\", \"403\", \"416\", \"418\", \"431\", \"437\", \"438\", \"450\", \"506\", \"514\", \"519\", \"548\", \"579\", \"581\", \"587\", \"604\", \"613\", \"639\", \"647\", \"672\", \"705\", \"709\", \"742\", \"778\", \"780\", \"782\", \"807\", \"819\", \"825\", \"867\", \"873\", \"902\", \"905\" ] ], [ \"Cape Verde (Kabu Verdi)\", \"cv\", \"238\" ], [ \"Caribbean Netherlands\", \"bq\", \"599\", 1, [ \"3\", \"4\", \"7\" ] ], [ \"Cayman Islands\", \"ky\", \"1\", 12, [ \"345\" ] ], [ \"Central African Republic (République centrafricaine)\", \"cf\", \"236\" ], [ \"Chad (Tchad)\", \"td\", \"235\" ], [ \"Chile\", \"cl\", \"56\" ], [ \"China (中国)\", \"cn\", \"86\" ], [ \"Christmas Island\", \"cx\", \"61\", 2, [ \"89164\" ] ], [ \"Cocos (Keeling) Islands\", \"cc\", \"61\", 1, [ \"89162\" ] ], [ \"Colombia\", \"co\", \"57\" ], [ \"Comoros (‫جزر القمر‬‎)\", \"km\", \"269\" ], [ \"Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)\", \"cd\", \"243\" ], [ \"Congo (Republic) (Congo-Brazzaville)\", \"cg\", \"242\" ], [ \"Cook Islands\", \"ck\", \"682\" ], [ \"Costa Rica\", \"cr\", \"506\" ], [ \"Côte d’Ivoire\", \"ci\", \"225\" ], [ \"Croatia (Hrvatska)\", \"hr\", \"385\" ], [ \"Cuba\", \"cu\", \"53\" ], [ \"Curaçao\", \"cw\", \"599\", 0 ], [ \"Cyprus (Κύπρος)\", \"cy\", \"357\" ], [ \"Czech Republic (Česká republika)\", \"cz\", \"420\" ], [ \"Denmark (Danmark)\", \"dk\", \"45\" ], [ \"Djibouti\", \"dj\", \"253\" ], [ \"Dominica\", \"dm\", \"1\", 13, [ \"767\" ] ], [ \"Dominican Republic (República Dominicana)\", \"do\", \"1\", 2, [ \"809\", \"829\", \"849\" ] ], [ \"Ecuador\", \"ec\", \"593\" ], [ \"Egypt (‫مصر‬‎)\", \"eg\", \"20\" ], [ \"El Salvador\", \"sv\", \"503\" ], [ \"Equatorial Guinea (Guinea Ecuatorial)\", \"gq\", \"240\" ], [ \"Eritrea\", \"er\", \"291\" ], [ \"Estonia (Eesti)\", \"ee\", \"372\" ], [ \"Eswatini\", \"sz\", \"268\" ], [ \"Ethiopia\", \"et\", \"251\" ], [ \"Falkland Islands (Islas Malvinas)\", \"fk\", \"500\" ], [ \"Faroe Islands (Føroyar)\", \"fo\", \"298\" ], [ \"Fiji\", \"fj\", \"679\" ], [ \"Finland (Suomi)\", \"fi\", \"358\", 0 ], [ \"France\", \"fr\", \"33\" ], [ \"French Guiana (Guyane française)\", \"gf\", \"594\" ], [ \"French Polynesia (Polynésie française)\", \"pf\", \"689\" ], [ \"Gabon\", \"ga\", \"241\" ], [ \"Gambia\", \"gm\", \"220\" ], [ \"Georgia (საქართველო)\", \"ge\", \"995\" ], [ \"Germany (Deutschland)\", \"de\", \"49\" ], [ \"Ghana (Gaana)\", \"gh\", \"233\" ], [ \"Gibraltar\", \"gi\", \"350\" ], [ \"Greece (Ελλάδα)\", \"gr\", \"30\" ], [ \"Greenland (Kalaallit Nunaat)\", \"gl\", \"299\" ], [ \"Grenada\", \"gd\", \"1\", 14, [ \"473\" ] ], [ \"Guadeloupe\", \"gp\", \"590\", 0 ], [ \"Guam\", \"gu\", \"1\", 15, [ \"671\" ] ], [ \"Guatemala\", \"gt\", \"502\" ], [ \"Guernsey\", \"gg\", \"44\", 1, [ \"1481\", \"7781\", \"7839\", \"7911\" ] ], [ \"Guinea (Guinée)\", \"gn\", \"224\" ], [ \"Guinea-Bissau (Guiné Bissau)\", \"gw\", \"245\" ], [ \"Guyana\", \"gy\", \"592\" ], [ \"Haiti\", \"ht\", \"509\" ], [ \"Honduras\", \"hn\", \"504\" ], [ \"Hong Kong (香港)\", \"hk\", \"852\" ], [ \"Hungary (Magyarország)\", \"hu\", \"36\" ], [ \"Iceland (Ísland)\", \"is\", \"354\" ], [ \"India (भारत)\", \"in\", \"91\" ], [ \"Indonesia\", \"id\", \"62\" ], [ \"Iran (‫ایران‬‎)\", \"ir\", \"98\" ], [ \"Iraq (‫العراق‬‎)\", \"iq\", \"964\" ], [ \"Ireland\", \"ie\", \"353\" ], [ \"Isle of Man\", \"im\", \"44\", 2, [ \"1624\", \"74576\", \"7524\", \"7924\", \"7624\" ] ], [ \"Israel (‫ישראל‬‎)\", \"il\", \"972\" ], [ \"Italy (Italia)\", \"it\", \"39\", 0 ], [ \"Jamaica\", \"jm\", \"1\", 4, [ \"876\", \"658\" ] ], [ \"Japan (日本)\", \"jp\", \"81\" ], [ \"Jersey\", \"je\", \"44\", 3, [ \"1534\", \"7509\", \"7700\", \"7797\", \"7829\", \"7937\" ] ], [ \"Jordan (‫الأردن‬‎)\", \"jo\", \"962\" ], [ \"Kazakhstan (Казахстан)\", \"kz\", \"7\", 1, [ \"33\", \"7\" ] ], [ \"Kenya\", \"ke\", \"254\" ], [ \"Kiribati\", \"ki\", \"686\" ], [ \"Kosovo\", \"xk\", \"383\" ], [ \"Kuwait (‫الكويت‬‎)\", \"kw\", \"965\" ], [ \"Kyrgyzstan (Кыргызстан)\", \"kg\", \"996\" ], [ \"Laos (ລາວ)\", \"la\", \"856\" ], [ \"Latvia (Latvija)\", \"lv\", \"371\" ], [ \"Lebanon (‫لبنان‬‎)\", \"lb\", \"961\" ], [ \"Lesotho\", \"ls\", \"266\" ], [ \"Liberia\", \"lr\", \"231\" ], [ \"Libya (‫ليبيا‬‎)\", \"ly\", \"218\" ], [ \"Liechtenstein\", \"li\", \"423\" ], [ \"Lithuania (Lietuva)\", \"lt\", \"370\" ], [ \"Luxembourg\", \"lu\", \"352\" ], [ \"Macau (澳門)\", \"mo\", \"853\" ], [ \"Macedonia (FYROM) (Македонија)\", \"mk\", \"389\" ], [ \"Madagascar (Madagasikara)\", \"mg\", \"261\" ], [ \"Malawi\", \"mw\", \"265\" ], [ \"Malaysia\", \"my\", \"60\" ], [ \"Maldives\", \"mv\", \"960\" ], [ \"Mali\", \"ml\", \"223\" ], [ \"Malta\", \"mt\", \"356\" ], [ \"Marshall Islands\", \"mh\", \"692\" ], [ \"Martinique\", \"mq\", \"596\" ], [ \"Mauritania (‫موريتانيا‬‎)\", \"mr\", \"222\" ], [ \"Mauritius (Moris)\", \"mu\", \"230\" ], [ \"Mayotte\", \"yt\", \"262\", 1, [ \"269\", \"639\" ] ], [ \"Mexico (México)\", \"mx\", \"52\" ], [ \"Micronesia\", \"fm\", \"691\" ], [ \"Moldova (Republica Moldova)\", \"md\", \"373\" ], [ \"Monaco\", \"mc\", \"377\" ], [ \"Mongolia (Монгол)\", \"mn\", \"976\" ], [ \"Montenegro (Crna Gora)\", \"me\", \"382\" ], [ \"Montserrat\", \"ms\", \"1\", 16, [ \"664\" ] ], [ \"Morocco (‫المغرب‬‎)\", \"ma\", \"212\", 0 ], [ \"Mozambique (Moçambique)\", \"mz\", \"258\" ], [ \"Myanmar (Burma) (မြန်မာ)\", \"mm\", \"95\" ], [ \"Namibia (Namibië)\", \"na\", \"264\" ], [ \"Nauru\", \"nr\", \"674\" ], [ \"Nepal (नेपाल)\", \"np\", \"977\" ], [ \"Netherlands (Nederland)\", \"nl\", \"31\" ], [ \"New Caledonia (Nouvelle-Calédonie)\", \"nc\", \"687\" ], [ \"New Zealand\", \"nz\", \"64\" ], [ \"Nicaragua\", \"ni\", \"505\" ], [ \"Niger (Nijar)\", \"ne\", \"227\" ], [ \"Nigeria\", \"ng\", \"234\" ], [ \"Niue\", \"nu\", \"683\" ], [ \"Norfolk Island\", \"nf\", \"672\" ], [ \"North Korea (조선 민주주의 인민 공화국)\", \"kp\", \"850\" ], [ \"Northern Mariana Islands\", \"mp\", \"1\", 17, [ \"670\" ] ], [ \"Norway (Norge)\", \"no\", \"47\", 0 ], [ \"Oman (‫عُمان‬‎)\", \"om\", \"968\" ], [ \"Pakistan (‫پاکستان‬‎)\", \"pk\", \"92\" ], [ \"Palau\", \"pw\", \"680\" ], [ \"Palestine (‫فلسطين‬‎)\", \"ps\", \"970\" ], [ \"Panama (Panamá)\", \"pa\", \"507\" ], [ \"Papua New Guinea\", \"pg\", \"675\" ], [ \"Paraguay\", \"py\", \"595\" ], [ \"Peru (Perú)\", \"pe\", \"51\" ], [ \"Philippines\", \"ph\", \"63\" ], [ \"Poland (Polska)\", \"pl\", \"48\" ], [ \"Portugal\", \"pt\", \"351\" ], [ \"Puerto Rico\", \"pr\", \"1\", 3, [ \"787\", \"939\" ] ], [ \"Qatar (‫قطر‬‎)\", \"qa\", \"974\" ], [ \"Réunion (La Réunion)\", \"re\", \"262\", 0 ], [ \"Romania (România)\", \"ro\", \"40\" ], [ \"Russia (Россия)\", \"ru\", \"7\", 0 ], [ \"Rwanda\", \"rw\", \"250\" ], [ \"Saint Barthélemy\", \"bl\", \"590\", 1 ], [ \"Saint Helena\", \"sh\", \"290\" ], [ \"Saint Kitts and Nevis\", \"kn\", \"1\", 18, [ \"869\" ] ], [ \"Saint Lucia\", \"lc\", \"1\", 19, [ \"758\" ] ], [ \"Saint Martin (Saint-Martin (partie française))\", \"mf\", \"590\", 2 ], [ \"Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)\", \"pm\", \"508\" ], [ \"Saint Vincent and the Grenadines\", \"vc\", \"1\", 20, [ \"784\" ] ], [ \"Samoa\", \"ws\", \"685\" ], [ \"San Marino\", \"sm\", \"378\" ], [ \"São Tomé and Príncipe (São Tomé e Príncipe)\", \"st\", \"239\" ], [ \"Saudi Arabia (‫المملكة العربية السعودية‬‎)\", \"sa\", \"966\" ], [ \"Senegal (Sénégal)\", \"sn\", \"221\" ], [ \"Serbia (Србија)\", \"rs\", \"381\" ], [ \"Seychelles\", \"sc\", \"248\" ], [ \"Sierra Leone\", \"sl\", \"232\" ], [ \"Singapore\", \"sg\", \"65\" ], [ \"Sint Maarten\", \"sx\", \"1\", 21, [ \"721\" ] ], [ \"Slovakia (Slovensko)\", \"sk\", \"421\" ], [ \"Slovenia (Slovenija)\", \"si\", \"386\" ], [ \"Solomon Islands\", \"sb\", \"677\" ], [ \"Somalia (Soomaaliya)\", \"so\", \"252\" ], [ \"South Africa\", \"za\", \"27\" ], [ \"South Korea (대한민국)\", \"kr\", \"82\" ], [ \"South Sudan (‫جنوب السودان‬‎)\", \"ss\", \"211\" ], [ \"Spain (España)\", \"es\", \"34\" ], [ \"Sri Lanka (ශ්‍රී ලංකාව)\", \"lk\", \"94\" ], [ \"Sudan (‫السودان‬‎)\", \"sd\", \"249\" ], [ \"Suriname\", \"sr\", \"597\" ], [ \"Svalbard and Jan Mayen\", \"sj\", \"47\", 1, [ \"79\" ] ], [ \"Sweden (Sverige)\", \"se\", \"46\" ], [ \"Switzerland (Schweiz)\", \"ch\", \"41\" ], [ \"Syria (‫سوريا‬‎)\", \"sy\", \"963\" ], [ \"Taiwan (台灣)\", \"tw\", \"886\" ], [ \"Tajikistan\", \"tj\", \"992\" ], [ \"Tanzania\", \"tz\", \"255\" ], [ \"Thailand (ไทย)\", \"th\", \"66\" ], [ \"Timor-Leste\", \"tl\", \"670\" ], [ \"Togo\", \"tg\", \"228\" ], [ \"Tokelau\", \"tk\", \"690\" ], [ \"Tonga\", \"to\", \"676\" ], [ \"Trinidad and Tobago\", \"tt\", \"1\", 22, [ \"868\" ] ], [ \"Tunisia (‫تونس‬‎)\", \"tn\", \"216\" ], [ \"Turkey (Türkiye)\", \"tr\", \"90\" ], [ \"Turkmenistan\", \"tm\", \"993\" ], [ \"Turks and Caicos Islands\", \"tc\", \"1\", 23, [ \"649\" ] ], [ \"Tuvalu\", \"tv\", \"688\" ], [ \"U.S. Virgin Islands\", \"vi\", \"1\", 24, [ \"340\" ] ], [ \"Uganda\", \"ug\", \"256\" ], [ \"Ukraine (Україна)\", \"ua\", \"380\" ], [ \"United Arab Emirates (‫الإمارات العربية المتحدة‬‎)\", \"ae\", \"971\" ], [ \"United Kingdom\", \"gb\", \"44\", 0 ], [ \"United States\", \"us\", \"1\", 0 ], [ \"Uruguay\", \"uy\", \"598\" ], [ \"Uzbekistan (Oʻzbekiston)\", \"uz\", \"998\" ], [ \"Vanuatu\", \"vu\", \"678\" ], [ \"Vatican City (Città del Vaticano)\", \"va\", \"39\", 1, [ \"06698\" ] ], [ \"Venezuela\", \"ve\", \"58\" ], [ \"Vietnam (Việt Nam)\", \"vn\", \"84\" ], [ \"Wallis and Futuna (Wallis-et-Futuna)\", \"wf\", \"681\" ], [ \"Western Sahara (‫الصحراء الغربية‬‎)\", \"eh\", \"212\", 1, [ \"5288\", \"5289\" ] ], [ \"Yemen (‫اليمن‬‎)\", \"ye\", \"967\" ], [ \"Zambia\", \"zm\", \"260\" ], [ \"Zimbabwe\", \"zw\", \"263\" ], [ \"Åland Islands\", \"ax\", \"358\", 1, [ \"18\" ] ] ];\n        // loop over all of the countries above, restructuring the data to be objects with named keys\n        for (var i = 0; i < allCountries.length; i++) {\n            var c = allCountries[i];\n            allCountries[i] = {\n                name: c[0],\n                iso2: c[1],\n                dialCode: c[2],\n                priority: c[3] || 0,\n                areaCodes: c[4] || null\n            };\n        }\n        \"use strict\";\n        function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n                throw new TypeError(\"Cannot call a class as a function\");\n            }\n        }\n        function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n                var descriptor = props[i];\n                descriptor.enumerable = descriptor.enumerable || false;\n                descriptor.configurable = true;\n                if (\"value\" in descriptor) descriptor.writable = true;\n                Object.defineProperty(target, descriptor.key, descriptor);\n            }\n        }\n        function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n        }\n        var intlTelInputGlobals = {\n            getInstance: function getInstance(input) {\n                var id = input.getAttribute(\"data-intl-tel-input-id\");\n                return window.intlTelInputGlobals.instances[id];\n            },\n            instances: {},\n            // using a global like this allows us to mock it in the tests\n            documentReady: function documentReady() {\n                return document.readyState === \"complete\";\n            }\n        };\n        if (typeof window === \"object\") window.intlTelInputGlobals = intlTelInputGlobals;\n        // these vars persist through all instances of the plugin\n        var id = 0;\n        var defaults = {\n            // whether or not to allow the dropdown\n            allowDropdown: true,\n            // if there is just a dial code in the input: remove it on blur\n            autoHideDialCode: true,\n            // add a placeholder in the input with an example number for the selected country\n            autoPlaceholder: \"polite\",\n            // modify the parentClass\n            customContainer: \"\",\n            // modify the auto placeholder\n            customPlaceholder: null,\n            // append menu to specified element\n            dropdownContainer: null,\n            // don't display these countries\n            excludeCountries: [],\n            // format the input value during initialisation and on setNumber\n            formatOnDisplay: true,\n            // geoIp lookup function\n            geoIpLookup: null,\n            // inject a hidden input with this name, and on submit, populate it with the result of getNumber\n            hiddenInput: \"\",\n            // initial country\n            initialCountry: \"\",\n            // localized country names e.g. { 'de': 'Deutschland' }\n            localizedCountries: null,\n            // don't insert international dial codes\n            nationalMode: true,\n            // display only these countries\n            onlyCountries: [],\n            // number type to use for placeholders\n            placeholderNumberType: \"MOBILE\",\n            // the countries at the top of the list. defaults to united states and united kingdom\n            preferredCountries: [ \"us\", \"gb\" ],\n            // display the country dial code next to the selected flag so it's not part of the typed number\n            separateDialCode: false,\n            // specify the path to the libphonenumber script to enable validation/formatting\n            utilsScript: \"\"\n        };\n        // https://en.wikipedia.org/wiki/List_of_North_American_Numbering_Plan_area_codes#Non-geographic_area_codes\n        var regionlessNanpNumbers = [ \"800\", \"822\", \"833\", \"844\", \"855\", \"866\", \"877\", \"880\", \"881\", \"882\", \"883\", \"884\", \"885\", \"886\", \"887\", \"888\", \"889\" ];\n        // utility function to iterate over an object. can't use Object.entries or native forEach because\n        // of IE11\n        var forEachProp = function forEachProp(obj, callback) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length; i++) {\n                callback(keys[i], obj[keys[i]]);\n            }\n        };\n        // run a method on each instance of the plugin\n        var forEachInstance = function forEachInstance(method) {\n            forEachProp(window.intlTelInputGlobals.instances, function(key) {\n                window.intlTelInputGlobals.instances[key][method]();\n            });\n        };\n        // this is our plugin class that we will create an instance of\n        // eslint-disable-next-line no-unused-vars\n        var Iti = /*#__PURE__*/\n        function() {\n            function Iti(input, options) {\n                var _this = this;\n                _classCallCheck(this, Iti);\n                this.id = id++;\n                this.telInput = input;\n                this.activeItem = null;\n                this.highlightedItem = null;\n                // process specified options / defaults\n                // alternative to Object.assign, which isn't supported by IE11\n                var customOptions = options || {};\n                this.options = {};\n                forEachProp(defaults, function(key, value) {\n                    _this.options[key] = customOptions.hasOwnProperty(key) ? customOptions[key] : value;\n                });\n                this.hadInitialPlaceholder = Boolean(input.getAttribute(\"placeholder\"));\n            }\n            _createClass(Iti, [ {\n                key: \"_init\",\n                value: function _init() {\n                    var _this2 = this;\n                    // if in nationalMode, disable options relating to dial codes\n                    if (this.options.nationalMode) this.options.autoHideDialCode = false;\n                    // if separateDialCode then doesn't make sense to A) insert dial code into input\n                    // (autoHideDialCode), and B) display national numbers (because we're displaying the country\n                    // dial code next to them)\n                    if (this.options.separateDialCode) {\n                        this.options.autoHideDialCode = this.options.nationalMode = false;\n                    }\n                    // we cannot just test screen size as some smartphones/website meta tags will report desktop\n                    // resolutions\n                    // Note: for some reason jasmine breaks if you put this in the main Plugin function with the\n                    // rest of these declarations\n                    // Note: to target Android Mobiles (and not Tablets), we must find 'Android' and 'Mobile'\n                    this.isMobile = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n                    if (this.isMobile) {\n                        // trigger the mobile dropdown css\n                        document.body.classList.add(\"iti-mobile\");\n                        // on mobile, we want a full screen dropdown, so we must append it to the body\n                        if (!this.options.dropdownContainer) this.options.dropdownContainer = document.body;\n                    }\n                    // these promises get resolved when their individual requests complete\n                    // this way the dev can do something like iti.promise.then(...) to know when all requests are\n                    // complete\n                    if (typeof Promise !== \"undefined\") {\n                        var autoCountryPromise = new Promise(function(resolve, reject) {\n                            _this2.resolveAutoCountryPromise = resolve;\n                            _this2.rejectAutoCountryPromise = reject;\n                        });\n                        var utilsScriptPromise = new Promise(function(resolve, reject) {\n                            _this2.resolveUtilsScriptPromise = resolve;\n                            _this2.rejectUtilsScriptPromise = reject;\n                        });\n                        this.promise = Promise.all([ autoCountryPromise, utilsScriptPromise ]);\n                    } else {\n                        // prevent errors when Promise doesn't exist\n                        this.resolveAutoCountryPromise = this.rejectAutoCountryPromise = function() {};\n                        this.resolveUtilsScriptPromise = this.rejectUtilsScriptPromise = function() {};\n                    }\n                    // in various situations there could be no country selected initially, but we need to be able\n                    // to assume this variable exists\n                    this.selectedCountryData = {};\n                    // process all the data: onlyCountries, excludeCountries, preferredCountries etc\n                    this._processCountryData();\n                    // generate the markup\n                    this._generateMarkup();\n                    // set the initial state of the input value and the selected flag\n                    this._setInitialState();\n                    // start all of the event listeners: autoHideDialCode, input keydown, selectedFlag click\n                    this._initListeners();\n                    // utils script, and auto country\n                    this._initRequests();\n                }\n            }, {\n                key: \"_processCountryData\",\n                value: function _processCountryData() {\n                    // process onlyCountries or excludeCountries array if present\n                    this._processAllCountries();\n                    // process the countryCodes map\n                    this._processCountryCodes();\n                    // process the preferredCountries\n                    this._processPreferredCountries();\n                    // translate countries according to localizedCountries option\n                    if (this.options.localizedCountries) this._translateCountriesByLocale();\n                    // sort countries by name\n                    if (this.options.onlyCountries.length || this.options.localizedCountries) {\n                        this.countries.sort(this._countryNameSort);\n                    }\n                }\n            }, {\n                key: \"_addCountryCode\",\n                value: function _addCountryCode(iso2, countryCode, priority) {\n                    if (countryCode.length > this.countryCodeMaxLen) {\n                        this.countryCodeMaxLen = countryCode.length;\n                    }\n                    if (!this.countryCodes.hasOwnProperty(countryCode)) {\n                        this.countryCodes[countryCode] = [];\n                    }\n                    // bail if we already have this country for this countryCode\n                    for (var i = 0; i < this.countryCodes[countryCode].length; i++) {\n                        if (this.countryCodes[countryCode][i] === iso2) return;\n                    }\n                    // check for undefined as 0 is falsy\n                    var index = priority !== undefined ? priority : this.countryCodes[countryCode].length;\n                    this.countryCodes[countryCode][index] = iso2;\n                }\n            }, {\n                key: \"_processAllCountries\",\n                value: function _processAllCountries() {\n                    if (this.options.onlyCountries.length) {\n                        var lowerCaseOnlyCountries = this.options.onlyCountries.map(function(country) {\n                            return country.toLowerCase();\n                        });\n                        this.countries = allCountries.filter(function(country) {\n                            return lowerCaseOnlyCountries.indexOf(country.iso2) > -1;\n                        });\n                    } else if (this.options.excludeCountries.length) {\n                        var lowerCaseExcludeCountries = this.options.excludeCountries.map(function(country) {\n                            return country.toLowerCase();\n                        });\n                        this.countries = allCountries.filter(function(country) {\n                            return lowerCaseExcludeCountries.indexOf(country.iso2) === -1;\n                        });\n                    } else {\n                        this.countries = allCountries;\n                    }\n                }\n            }, {\n                key: \"_translateCountriesByLocale\",\n                value: function _translateCountriesByLocale() {\n                    for (var i = 0; i < this.countries.length; i++) {\n                        var iso = this.countries[i].iso2.toLowerCase();\n                        if (this.options.localizedCountries.hasOwnProperty(iso)) {\n                            this.countries[i].name = this.options.localizedCountries[iso];\n                        }\n                    }\n                }\n            }, {\n                key: \"_countryNameSort\",\n                value: function _countryNameSort(a, b) {\n                    return a.name.localeCompare(b.name);\n                }\n            }, {\n                key: \"_processCountryCodes\",\n                value: function _processCountryCodes() {\n                    this.countryCodeMaxLen = 0;\n                    // here we store just dial codes\n                    this.dialCodes = {};\n                    // here we store \"country codes\" (both dial codes and their area codes)\n                    this.countryCodes = {};\n                    // first: add dial codes\n                    for (var i = 0; i < this.countries.length; i++) {\n                        var c = this.countries[i];\n                        if (!this.dialCodes[c.dialCode]) this.dialCodes[c.dialCode] = true;\n                        this._addCountryCode(c.iso2, c.dialCode, c.priority);\n                    }\n                    // next: add area codes\n                    // this is a second loop over countries, to make sure we have all of the \"root\" countries\n                    // already in the map, so that we can access them, as each time we add an area code substring\n                    // to the map, we also need to include the \"root\" country's code, as that also matches\n                    for (var _i = 0; _i < this.countries.length; _i++) {\n                        var _c = this.countries[_i];\n                        // area codes\n                        if (_c.areaCodes) {\n                            var rootCountryCode = this.countryCodes[_c.dialCode][0];\n                            // for each area code\n                            for (var j = 0; j < _c.areaCodes.length; j++) {\n                                var areaCode = _c.areaCodes[j];\n                                // for each digit in the area code to add all partial matches as well\n                                for (var k = 1; k < areaCode.length; k++) {\n                                    var partialDialCode = _c.dialCode + areaCode.substr(0, k);\n                                    // start with the root country, as that also matches this dial code\n                                    this._addCountryCode(rootCountryCode, partialDialCode);\n                                    this._addCountryCode(_c.iso2, partialDialCode);\n                                }\n                                // add the full area code\n                                this._addCountryCode(_c.iso2, _c.dialCode + areaCode);\n                            }\n                        }\n                    }\n                }\n            }, {\n                key: \"_processPreferredCountries\",\n                value: function _processPreferredCountries() {\n                    this.preferredCountries = [];\n                    for (var i = 0; i < this.options.preferredCountries.length; i++) {\n                        var countryCode = this.options.preferredCountries[i].toLowerCase();\n                        var countryData = this._getCountryData(countryCode, false, true);\n                        if (countryData) this.preferredCountries.push(countryData);\n                    }\n                }\n            }, {\n                key: \"_createEl\",\n                value: function _createEl(name, attrs, container) {\n                    var el = document.createElement(name);\n                    if (attrs) forEachProp(attrs, function(key, value) {\n                        return el.setAttribute(key, value);\n                    });\n                    if (container) container.appendChild(el);\n                    return el;\n                }\n            }, {\n                key: \"_generateMarkup\",\n                value: function _generateMarkup() {\n                    // if autocomplete does not exist on the element and its form, then\n                    // prevent autocomplete as there's no safe, cross-browser event we can react to, so it can\n                    // easily put the plugin in an inconsistent state e.g. the wrong flag selected for the\n                    // autocompleted number, which on submit could mean wrong number is saved (esp in nationalMode)\n                    if (!this.telInput.hasAttribute(\"autocomplete\") && !(this.telInput.form && this.telInput.form.hasAttribute(\"autocomplete\"))) {\n                        this.telInput.setAttribute(\"autocomplete\", \"off\");\n                    }\n                    // containers (mostly for positioning)\n                    var parentClass = \"iti\";\n                    if (this.options.allowDropdown) parentClass += \" iti--allow-dropdown\";\n                    if (this.options.separateDialCode) parentClass += \" iti--separate-dial-code\";\n                    if (this.options.customContainer) {\n                        parentClass += \" \";\n                        parentClass += this.options.customContainer;\n                    }\n                    var wrapper = this._createEl(\"div\", {\n                        \"class\": parentClass\n                    });\n                    this.telInput.parentNode.insertBefore(wrapper, this.telInput);\n                    this.flagsContainer = this._createEl(\"div\", {\n                        \"class\": \"iti__flag-container\"\n                    }, wrapper);\n                    wrapper.appendChild(this.telInput);\n                    // selected flag (displayed to left of input)\n                    this.selectedFlag = this._createEl(\"div\", {\n                        \"class\": \"iti__selected-flag\",\n                        role: \"combobox\",\n                        \"aria-controls\": \"iti-\".concat(this.id, \"__country-listbox\"),\n                        \"aria-owns\": \"iti-\".concat(this.id, \"__country-listbox\"),\n                        \"aria-expanded\": \"false\"\n                    }, this.flagsContainer);\n                    this.selectedFlagInner = this._createEl(\"div\", {\n                        \"class\": \"iti__flag\"\n                    }, this.selectedFlag);\n                    if (this.options.separateDialCode) {\n                        this.selectedDialCode = this._createEl(\"div\", {\n                            \"class\": \"iti__selected-dial-code\"\n                        }, this.selectedFlag);\n                    }\n                    if (this.options.allowDropdown) {\n                        // make element focusable and tab navigable\n                        this.selectedFlag.setAttribute(\"tabindex\", \"0\");\n                        this.dropdownArrow = this._createEl(\"div\", {\n                            \"class\": \"iti__arrow\"\n                        }, this.selectedFlag);\n                        // country dropdown: preferred countries, then divider, then all countries\n                        this.countryList = this._createEl(\"ul\", {\n                            \"class\": \"iti__country-list iti__hide\",\n                            id: \"iti-\".concat(this.id, \"__country-listbox\"),\n                            role: \"listbox\",\n                            \"aria-label\": \"List of countries\"\n                        });\n                        if (this.preferredCountries.length) {\n                            this._appendListItems(this.preferredCountries, \"iti__preferred\", true);\n                            this._createEl(\"li\", {\n                                \"class\": \"iti__divider\",\n                                role: \"separator\",\n                                \"aria-disabled\": \"true\"\n                            }, this.countryList);\n                        }\n                        this._appendListItems(this.countries, \"iti__standard\");\n                        // create dropdownContainer markup\n                        if (this.options.dropdownContainer) {\n                            this.dropdown = this._createEl(\"div\", {\n                                \"class\": \"iti iti--container\"\n                            });\n                            this.dropdown.appendChild(this.countryList);\n                        } else {\n                            this.flagsContainer.appendChild(this.countryList);\n                        }\n                    }\n                    if (this.options.hiddenInput) {\n                        var hiddenInputName = this.options.hiddenInput;\n                        var name = this.telInput.getAttribute(\"name\");\n                        if (name) {\n                            var i = name.lastIndexOf(\"[\");\n                            // if input name contains square brackets, then give the hidden input the same name,\n                            // replacing the contents of the last set of brackets with the given hiddenInput name\n                            if (i !== -1) hiddenInputName = \"\".concat(name.substr(0, i), \"[\").concat(hiddenInputName, \"]\");\n                        }\n                        this.hiddenInput = this._createEl(\"input\", {\n                            type: \"hidden\",\n                            name: hiddenInputName\n                        });\n                        wrapper.appendChild(this.hiddenInput);\n                    }\n                }\n            }, {\n                key: \"_appendListItems\",\n                value: function _appendListItems(countries, className, preferred) {\n                    // we create so many DOM elements, it is faster to build a temp string\n                    // and then add everything to the DOM in one go at the end\n                    var tmp = \"\";\n                    // for each country\n                    for (var i = 0; i < countries.length; i++) {\n                        var c = countries[i];\n                        var idSuffix = preferred ? \"-preferred\" : \"\";\n                        // open the list item\n                        tmp += \"<li class='iti__country \".concat(className, \"' tabIndex='-1' id='iti-\").concat(this.id, \"__item-\").concat(c.iso2).concat(idSuffix, \"' role='option' data-dial-code='\").concat(c.dialCode, \"' data-country-code='\").concat(c.iso2, \"' aria-selected='false'>\");\n                        // add the flag\n                        tmp += \"<div class='iti__flag-box'><div class='iti__flag iti__\".concat(c.iso2, \"'></div></div>\");\n                        // and the country name and dial code\n                        tmp += \"<span class='iti__country-name'>\".concat(c.name, \"</span>\");\n                        tmp += \"<span class='iti__dial-code'>+\".concat(c.dialCode, \"</span>\");\n                        // close the list item\n                        tmp += \"</li>\";\n                    }\n                    this.countryList.insertAdjacentHTML(\"beforeend\", tmp);\n                }\n            }, {\n                key: \"_setInitialState\",\n                value: function _setInitialState() {\n                    // fix firefox bug: when first load page (with input with value set to number with intl dial\n                    // code) and initialising plugin removes the dial code from the input, then refresh page,\n                    // and we try to init plugin again but this time on number without dial code so get grey flag\n                    var attributeValue = this.telInput.getAttribute(\"value\");\n                    var inputValue = this.telInput.value;\n                    var useAttribute = attributeValue && attributeValue.charAt(0) === \"+\" && (!inputValue || inputValue.charAt(0) !== \"+\");\n                    var val = useAttribute ? attributeValue : inputValue;\n                    var dialCode = this._getDialCode(val);\n                    var isRegionlessNanp = this._isRegionlessNanp(val);\n                    var _this$options = this.options, initialCountry = _this$options.initialCountry, nationalMode = _this$options.nationalMode, autoHideDialCode = _this$options.autoHideDialCode, separateDialCode = _this$options.separateDialCode;\n                    // if we already have a dial code, and it's not a regionlessNanp, we can go ahead and set the\n                    // flag, else fall back to the default country\n                    if (dialCode && !isRegionlessNanp) {\n                        this._updateFlagFromNumber(val);\n                    } else if (initialCountry !== \"auto\") {\n                        // see if we should select a flag\n                        if (initialCountry) {\n                            this._setFlag(initialCountry.toLowerCase());\n                        } else {\n                            if (dialCode && isRegionlessNanp) {\n                                // has intl dial code, is regionless nanp, and no initialCountry, so default to US\n                                this._setFlag(\"us\");\n                            } else {\n                                // no dial code and no initialCountry, so default to first in list\n                                this.defaultCountry = this.preferredCountries.length ? this.preferredCountries[0].iso2 : this.countries[0].iso2;\n                                if (!val) {\n                                    this._setFlag(this.defaultCountry);\n                                }\n                            }\n                        }\n                        // if empty and no nationalMode and no autoHideDialCode then insert the default dial code\n                        if (!val && !nationalMode && !autoHideDialCode && !separateDialCode) {\n                            this.telInput.value = \"+\".concat(this.selectedCountryData.dialCode);\n                        }\n                    }\n                    // NOTE: if initialCountry is set to auto, that will be handled separately\n                    // format - note this wont be run after _updateDialCode as that's only called if no val\n                    if (val) this._updateValFromNumber(val);\n                }\n            }, {\n                key: \"_initListeners\",\n                value: function _initListeners() {\n                    this._initKeyListeners();\n                    if (this.options.autoHideDialCode) this._initBlurListeners();\n                    if (this.options.allowDropdown) this._initDropdownListeners();\n                    if (this.hiddenInput) this._initHiddenInputListener();\n                }\n            }, {\n                key: \"_initHiddenInputListener\",\n                value: function _initHiddenInputListener() {\n                    var _this3 = this;\n                    this._handleHiddenInputSubmit = function() {\n                        _this3.hiddenInput.value = _this3.getNumber();\n                    };\n                    if (this.telInput.form) this.telInput.form.addEventListener(\"submit\", this._handleHiddenInputSubmit);\n                }\n            }, {\n                key: \"_getClosestLabel\",\n                value: function _getClosestLabel() {\n                    var el = this.telInput;\n                    while (el && el.tagName !== \"LABEL\") {\n                        el = el.parentNode;\n                    }\n                    return el;\n                }\n            }, {\n                key: \"_initDropdownListeners\",\n                value: function _initDropdownListeners() {\n                    var _this4 = this;\n                    // hack for input nested inside label (which is valid markup): clicking the selected-flag to\n                    // open the dropdown would then automatically trigger a 2nd click on the input which would\n                    // close it again\n                    this._handleLabelClick = function(e) {\n                        // if the dropdown is closed, then focus the input, else ignore the click\n                        if (_this4.countryList.classList.contains(\"iti__hide\")) _this4.telInput.focus(); else e.preventDefault();\n                    };\n                    var label = this._getClosestLabel();\n                    if (label) label.addEventListener(\"click\", this._handleLabelClick);\n                    // toggle country dropdown on click\n                    this._handleClickSelectedFlag = function() {\n                        // only intercept this event if we're opening the dropdown\n                        // else let it bubble up to the top (\"click-off-to-close\" listener)\n                        // we cannot just stopPropagation as it may be needed to close another instance\n                        if (_this4.countryList.classList.contains(\"iti__hide\") && !_this4.telInput.disabled && !_this4.telInput.readOnly) {\n                            _this4._showDropdown();\n                        }\n                    };\n                    this.selectedFlag.addEventListener(\"click\", this._handleClickSelectedFlag);\n                    // open dropdown list if currently focused\n                    this._handleFlagsContainerKeydown = function(e) {\n                        var isDropdownHidden = _this4.countryList.classList.contains(\"iti__hide\");\n                        if (isDropdownHidden && [ \"ArrowUp\", \"Up\", \"ArrowDown\", \"Down\", \" \", \"Enter\" ].indexOf(e.key) !== -1) {\n                            // prevent form from being submitted if \"ENTER\" was pressed\n                            e.preventDefault();\n                            // prevent event from being handled again by document\n                            e.stopPropagation();\n                            _this4._showDropdown();\n                        }\n                        // allow navigation from dropdown to input on TAB\n                        if (e.key === \"Tab\") _this4._closeDropdown();\n                    };\n                    this.flagsContainer.addEventListener(\"keydown\", this._handleFlagsContainerKeydown);\n                }\n            }, {\n                key: \"_initRequests\",\n                value: function _initRequests() {\n                    var _this5 = this;\n                    // if the user has specified the path to the utils script, fetch it on window.load, else resolve\n                    if (this.options.utilsScript && !window.intlTelInputUtils) {\n                        // if the plugin is being initialised after the window.load event has already been fired\n                        if (window.intlTelInputGlobals.documentReady()) {\n                            window.intlTelInputGlobals.loadUtils(this.options.utilsScript);\n                        } else {\n                            // wait until the load event so we don't block any other requests e.g. the flags image\n                            window.addEventListener(\"load\", function() {\n                                window.intlTelInputGlobals.loadUtils(_this5.options.utilsScript);\n                            });\n                        }\n                    } else this.resolveUtilsScriptPromise();\n                    if (this.options.initialCountry === \"auto\") this._loadAutoCountry(); else this.resolveAutoCountryPromise();\n                }\n            }, {\n                key: \"_loadAutoCountry\",\n                value: function _loadAutoCountry() {\n                    // 3 options:\n                    // 1) already loaded (we're done)\n                    // 2) not already started loading (start)\n                    // 3) already started loading (do nothing - just wait for loading callback to fire)\n                    if (window.intlTelInputGlobals.autoCountry) {\n                        this.handleAutoCountry();\n                    } else if (!window.intlTelInputGlobals.startedLoadingAutoCountry) {\n                        // don't do this twice!\n                        window.intlTelInputGlobals.startedLoadingAutoCountry = true;\n                        if (typeof this.options.geoIpLookup === \"function\") {\n                            this.options.geoIpLookup(function(countryCode) {\n                                window.intlTelInputGlobals.autoCountry = countryCode.toLowerCase();\n                                // tell all instances the auto country is ready\n                                // TODO: this should just be the current instances\n                                // UPDATE: use setTimeout in case their geoIpLookup function calls this callback straight\n                                // away (e.g. if they have already done the geo ip lookup somewhere else). Using\n                                // setTimeout means that the current thread of execution will finish before executing\n                                // this, which allows the plugin to finish initialising.\n                                setTimeout(function() {\n                                    return forEachInstance(\"handleAutoCountry\");\n                                });\n                            }, function() {\n                                return forEachInstance(\"rejectAutoCountryPromise\");\n                            });\n                        }\n                    }\n                }\n            }, {\n                key: \"_initKeyListeners\",\n                value: function _initKeyListeners() {\n                    var _this6 = this;\n                    // update flag on keyup\n                    this._handleKeyupEvent = function() {\n                        if (_this6._updateFlagFromNumber(_this6.telInput.value)) {\n                            _this6._triggerCountryChange();\n                        }\n                    };\n                    this.telInput.addEventListener(\"keyup\", this._handleKeyupEvent);\n                    // update flag on cut/paste events (now supported in all major browsers)\n                    this._handleClipboardEvent = function() {\n                        // hack because \"paste\" event is fired before input is updated\n                        setTimeout(_this6._handleKeyupEvent);\n                    };\n                    this.telInput.addEventListener(\"cut\", this._handleClipboardEvent);\n                    this.telInput.addEventListener(\"paste\", this._handleClipboardEvent);\n                }\n            }, {\n                key: \"_cap\",\n                value: function _cap(number) {\n                    var max = this.telInput.getAttribute(\"maxlength\");\n                    return max && number.length > max ? number.substr(0, max) : number;\n                }\n            }, {\n                key: \"_initBlurListeners\",\n                value: function _initBlurListeners() {\n                    var _this7 = this;\n                    // on blur or form submit: if just a dial code then remove it\n                    this._handleSubmitOrBlurEvent = function() {\n                        _this7._removeEmptyDialCode();\n                    };\n                    if (this.telInput.form) this.telInput.form.addEventListener(\"submit\", this._handleSubmitOrBlurEvent);\n                    this.telInput.addEventListener(\"blur\", this._handleSubmitOrBlurEvent);\n                }\n            }, {\n                key: \"_removeEmptyDialCode\",\n                value: function _removeEmptyDialCode() {\n                    if (this.telInput.value.charAt(0) === \"+\") {\n                        var numeric = this._getNumeric(this.telInput.value);\n                        // if just a plus, or if just a dial code\n                        if (!numeric || this.selectedCountryData.dialCode === numeric) {\n                            this.telInput.value = \"\";\n                        }\n                    }\n                }\n            }, {\n                key: \"_getNumeric\",\n                value: function _getNumeric(s) {\n                    return s.replace(/\\D/g, \"\");\n                }\n            }, {\n                key: \"_trigger\",\n                value: function _trigger(name) {\n                    // have to use old school document.createEvent as IE11 doesn't support `new Event()` syntax\n                    var e = document.createEvent(\"Event\");\n                    e.initEvent(name, true, true);\n                    // can bubble, and is cancellable\n                    this.telInput.dispatchEvent(e);\n                }\n            }, {\n                key: \"_showDropdown\",\n                value: function _showDropdown() {\n                    this.countryList.classList.remove(\"iti__hide\");\n                    this.selectedFlag.setAttribute(\"aria-expanded\", \"true\");\n                    this._setDropdownPosition();\n                    // update highlighting and scroll to active list item\n                    if (this.activeItem) {\n                        this._highlightListItem(this.activeItem, false);\n                        this._scrollTo(this.activeItem, true);\n                    }\n                    // bind all the dropdown-related listeners: mouseover, click, click-off, keydown\n                    this._bindDropdownListeners();\n                    // update the arrow\n                    this.dropdownArrow.classList.add(\"iti__arrow--up\");\n                    this._trigger(\"open:countrydropdown\");\n                }\n            }, {\n                key: \"_toggleClass\",\n                value: function _toggleClass(el, className, shouldHaveClass) {\n                    if (shouldHaveClass && !el.classList.contains(className)) el.classList.add(className); else if (!shouldHaveClass && el.classList.contains(className)) el.classList.remove(className);\n                }\n            }, {\n                key: \"_setDropdownPosition\",\n                value: function _setDropdownPosition() {\n                    var _this8 = this;\n                    if (this.options.dropdownContainer) {\n                        this.options.dropdownContainer.appendChild(this.dropdown);\n                    }\n                    if (!this.isMobile) {\n                        var pos = this.telInput.getBoundingClientRect();\n                        // windowTop from https://stackoverflow.com/a/14384091/217866\n                        var windowTop = window.pageYOffset || document.documentElement.scrollTop;\n                        var inputTop = pos.top + windowTop;\n                        var dropdownHeight = this.countryList.offsetHeight;\n                        // dropdownFitsBelow = (dropdownBottom < windowBottom)\n                        var dropdownFitsBelow = inputTop + this.telInput.offsetHeight + dropdownHeight < windowTop + window.innerHeight;\n                        var dropdownFitsAbove = inputTop - dropdownHeight > windowTop;\n                        // by default, the dropdown will be below the input. If we want to position it above the\n                        // input, we add the dropup class.\n                        this._toggleClass(this.countryList, \"iti__country-list--dropup\", !dropdownFitsBelow && dropdownFitsAbove);\n                        // if dropdownContainer is enabled, calculate postion\n                        if (this.options.dropdownContainer) {\n                            // by default the dropdown will be directly over the input because it's not in the flow.\n                            // If we want to position it below, we need to add some extra top value.\n                            var extraTop = !dropdownFitsBelow && dropdownFitsAbove ? 0 : this.telInput.offsetHeight;\n                            // calculate placement\n                            this.dropdown.style.top = \"\".concat(inputTop + extraTop, \"px\");\n                            this.dropdown.style.left = \"\".concat(pos.left + document.body.scrollLeft, \"px\");\n                            // close menu on window scroll\n                            this._handleWindowScroll = function() {\n                                return _this8._closeDropdown();\n                            };\n                            window.addEventListener(\"scroll\", this._handleWindowScroll);\n                        }\n                    }\n                }\n            }, {\n                key: \"_getClosestListItem\",\n                value: function _getClosestListItem(target) {\n                    var el = target;\n                    while (el && el !== this.countryList && !el.classList.contains(\"iti__country\")) {\n                        el = el.parentNode;\n                    }\n                    // if we reached the countryList element, then return null\n                    return el === this.countryList ? null : el;\n                }\n            }, {\n                key: \"_bindDropdownListeners\",\n                value: function _bindDropdownListeners() {\n                    var _this9 = this;\n                    // when mouse over a list item, just highlight that one\n                    // we add the class \"highlight\", so if they hit \"enter\" we know which one to select\n                    this._handleMouseoverCountryList = function(e) {\n                        // handle event delegation, as we're listening for this event on the countryList\n                        var listItem = _this9._getClosestListItem(e.target);\n                        if (listItem) _this9._highlightListItem(listItem, false);\n                    };\n                    this.countryList.addEventListener(\"mouseover\", this._handleMouseoverCountryList);\n                    // listen for country selection\n                    this._handleClickCountryList = function(e) {\n                        var listItem = _this9._getClosestListItem(e.target);\n                        if (listItem) _this9._selectListItem(listItem);\n                    };\n                    this.countryList.addEventListener(\"click\", this._handleClickCountryList);\n                    // click off to close\n                    // (except when this initial opening click is bubbling up)\n                    // we cannot just stopPropagation as it may be needed to close another instance\n                    var isOpening = true;\n                    this._handleClickOffToClose = function() {\n                        if (!isOpening) _this9._closeDropdown();\n                        isOpening = false;\n                    };\n                    document.documentElement.addEventListener(\"click\", this._handleClickOffToClose);\n                    // listen for up/down scrolling, enter to select, or letters to jump to country name.\n                    // use keydown as keypress doesn't fire for non-char keys and we want to catch if they\n                    // just hit down and hold it to scroll down (no keyup event).\n                    // listen on the document because that's where key events are triggered if no input has focus\n                    var query = \"\";\n                    var queryTimer = null;\n                    this._handleKeydownOnDropdown = function(e) {\n                        // prevent down key from scrolling the whole page,\n                        // and enter key from submitting a form etc\n                        e.preventDefault();\n                        // up and down to navigate\n                        if (e.key === \"ArrowUp\" || e.key === \"Up\" || e.key === \"ArrowDown\" || e.key === \"Down\") _this9._handleUpDownKey(e.key); else if (e.key === \"Enter\") _this9._handleEnterKey(); else if (e.key === \"Escape\") _this9._closeDropdown(); else if (/^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(e.key)) {\n                            // jump to countries that start with the query string\n                            if (queryTimer) clearTimeout(queryTimer);\n                            query += e.key.toLowerCase();\n                            _this9._searchForCountry(query);\n                            // if the timer hits 1 second, reset the query\n                            queryTimer = setTimeout(function() {\n                                query = \"\";\n                            }, 1e3);\n                        }\n                    };\n                    document.addEventListener(\"keydown\", this._handleKeydownOnDropdown);\n                }\n            }, {\n                key: \"_handleUpDownKey\",\n                value: function _handleUpDownKey(key) {\n                    var next = key === \"ArrowUp\" || key === \"Up\" ? this.highlightedItem.previousElementSibling : this.highlightedItem.nextElementSibling;\n                    if (next) {\n                        // skip the divider\n                        if (next.classList.contains(\"iti__divider\")) {\n                            next = key === \"ArrowUp\" || key === \"Up\" ? next.previousElementSibling : next.nextElementSibling;\n                        }\n                        this._highlightListItem(next, true);\n                    }\n                }\n            }, {\n                key: \"_handleEnterKey\",\n                value: function _handleEnterKey() {\n                    if (this.highlightedItem) this._selectListItem(this.highlightedItem);\n                }\n            }, {\n                key: \"_searchForCountry\",\n                value: function _searchForCountry(query) {\n                    for (var i = 0; i < this.countries.length; i++) {\n                        if (this._startsWith(this.countries[i].name, query)) {\n                            var listItem = this.countryList.querySelector(\"#iti-\".concat(this.id, \"__item-\").concat(this.countries[i].iso2));\n                            // update highlighting and scroll\n                            this._highlightListItem(listItem, false);\n                            this._scrollTo(listItem, true);\n                            break;\n                        }\n                    }\n                }\n            }, {\n                key: \"_startsWith\",\n                value: function _startsWith(a, b) {\n                    return a.substr(0, b.length).toLowerCase() === b;\n                }\n            }, {\n                key: \"_updateValFromNumber\",\n                value: function _updateValFromNumber(originalNumber) {\n                    var number = originalNumber;\n                    if (this.options.formatOnDisplay && window.intlTelInputUtils && this.selectedCountryData) {\n                        var useNational = !this.options.separateDialCode && (this.options.nationalMode || number.charAt(0) !== \"+\");\n                        var _intlTelInputUtils$nu = intlTelInputUtils.numberFormat, NATIONAL = _intlTelInputUtils$nu.NATIONAL, INTERNATIONAL = _intlTelInputUtils$nu.INTERNATIONAL;\n                        var format = useNational ? NATIONAL : INTERNATIONAL;\n                        number = intlTelInputUtils.formatNumber(number, this.selectedCountryData.iso2, format);\n                    }\n                    number = this._beforeSetNumber(number);\n                    this.telInput.value = number;\n                }\n            }, {\n                key: \"_updateFlagFromNumber\",\n                value: function _updateFlagFromNumber(originalNumber) {\n                    // if we're in nationalMode and we already have US/Canada selected, make sure the number starts\n                    // with a +1 so _getDialCode will be able to extract the area code\n                    // update: if we dont yet have selectedCountryData, but we're here (trying to update the flag\n                    // from the number), that means we're initialising the plugin with a number that already has a\n                    // dial code, so fine to ignore this bit\n                    var number = originalNumber;\n                    var selectedDialCode = this.selectedCountryData.dialCode;\n                    var isNanp = selectedDialCode === \"1\";\n                    if (number && this.options.nationalMode && isNanp && number.charAt(0) !== \"+\") {\n                        if (number.charAt(0) !== \"1\") number = \"1\".concat(number);\n                        number = \"+\".concat(number);\n                    }\n                    // update flag if user types area code for another country\n                    if (this.options.separateDialCode && selectedDialCode && number.charAt(0) !== \"+\") {\n                        number = \"+\".concat(selectedDialCode).concat(number);\n                    }\n                    // try and extract valid dial code from input\n                    var dialCode = this._getDialCode(number, true);\n                    var numeric = this._getNumeric(number);\n                    var countryCode = null;\n                    if (dialCode) {\n                        var countryCodes = this.countryCodes[this._getNumeric(dialCode)];\n                        // check if the right country is already selected. this should be false if the number is\n                        // longer than the matched dial code because in this case we need to make sure that if\n                        // there are multiple country matches, that the first one is selected (note: we could\n                        // just check that here, but it requires the same loop that we already have later)\n                        var alreadySelected = countryCodes.indexOf(this.selectedCountryData.iso2) !== -1 && numeric.length <= dialCode.length - 1;\n                        var isRegionlessNanpNumber = selectedDialCode === \"1\" && this._isRegionlessNanp(numeric);\n                        // only update the flag if:\n                        // A) NOT (we currently have a NANP flag selected, and the number is a regionlessNanp)\n                        // AND\n                        // B) the right country is not already selected\n                        if (!isRegionlessNanpNumber && !alreadySelected) {\n                            // if using onlyCountries option, countryCodes[0] may be empty, so we must find the first\n                            // non-empty index\n                            for (var j = 0; j < countryCodes.length; j++) {\n                                if (countryCodes[j]) {\n                                    countryCode = countryCodes[j];\n                                    break;\n                                }\n                            }\n                        }\n                    } else if (number.charAt(0) === \"+\" && numeric.length) {\n                        // invalid dial code, so empty\n                        // Note: use getNumeric here because the number has not been formatted yet, so could contain\n                        // bad chars\n                        countryCode = \"\";\n                    } else if (!number || number === \"+\") {\n                        // empty, or just a plus, so default\n                        countryCode = this.defaultCountry;\n                    }\n                    if (countryCode !== null) {\n                        return this._setFlag(countryCode);\n                    }\n                    return false;\n                }\n            }, {\n                key: \"_isRegionlessNanp\",\n                value: function _isRegionlessNanp(number) {\n                    var numeric = this._getNumeric(number);\n                    if (numeric.charAt(0) === \"1\") {\n                        var areaCode = numeric.substr(1, 3);\n                        return regionlessNanpNumbers.indexOf(areaCode) !== -1;\n                    }\n                    return false;\n                }\n            }, {\n                key: \"_highlightListItem\",\n                value: function _highlightListItem(listItem, shouldFocus) {\n                    var prevItem = this.highlightedItem;\n                    if (prevItem) prevItem.classList.remove(\"iti__highlight\");\n                    this.highlightedItem = listItem;\n                    this.highlightedItem.classList.add(\"iti__highlight\");\n                    if (shouldFocus) this.highlightedItem.focus();\n                }\n            }, {\n                key: \"_getCountryData\",\n                value: function _getCountryData(countryCode, ignoreOnlyCountriesOption, allowFail) {\n                    var countryList = ignoreOnlyCountriesOption ? allCountries : this.countries;\n                    for (var i = 0; i < countryList.length; i++) {\n                        if (countryList[i].iso2 === countryCode) {\n                            return countryList[i];\n                        }\n                    }\n                    if (allowFail) {\n                        return null;\n                    }\n                    throw new Error(\"No country data for '\".concat(countryCode, \"'\"));\n                }\n            }, {\n                key: \"_setFlag\",\n                value: function _setFlag(countryCode) {\n                    var prevCountry = this.selectedCountryData.iso2 ? this.selectedCountryData : {};\n                    // do this first as it will throw an error and stop if countryCode is invalid\n                    this.selectedCountryData = countryCode ? this._getCountryData(countryCode, false, false) : {};\n                    // update the defaultCountry - we only need the iso2 from now on, so just store that\n                    if (this.selectedCountryData.iso2) {\n                        this.defaultCountry = this.selectedCountryData.iso2;\n                    }\n                    this.selectedFlagInner.setAttribute(\"class\", \"iti__flag iti__\".concat(countryCode));\n                    // update the selected country's title attribute\n                    var title = countryCode ? \"\".concat(this.selectedCountryData.name, \": +\").concat(this.selectedCountryData.dialCode) : \"Unknown\";\n                    this.selectedFlag.setAttribute(\"title\", title);\n                    if (this.options.separateDialCode) {\n                        var dialCode = this.selectedCountryData.dialCode ? \"+\".concat(this.selectedCountryData.dialCode) : \"\";\n                        this.selectedDialCode.innerHTML = dialCode;\n                        // offsetWidth is zero if input is in a hidden container during initialisation\n                        var selectedFlagWidth = this.selectedFlag.offsetWidth || this._getHiddenSelectedFlagWidth();\n                        // add 6px of padding after the grey selected-dial-code box, as this is what we use in the css\n                        this.telInput.style.paddingLeft = \"\".concat(selectedFlagWidth + 6, \"px\");\n                    }\n                    // and the input's placeholder\n                    this._updatePlaceholder();\n                    // update the active list item\n                    if (this.options.allowDropdown) {\n                        var prevItem = this.activeItem;\n                        if (prevItem) {\n                            prevItem.classList.remove(\"iti__active\");\n                            prevItem.setAttribute(\"aria-selected\", \"false\");\n                        }\n                        if (countryCode) {\n                            // check if there is a preferred item first, else fall back to standard\n                            var nextItem = this.countryList.querySelector(\"#iti-\".concat(this.id, \"__item-\").concat(countryCode, \"-preferred\")) || this.countryList.querySelector(\"#iti-\".concat(this.id, \"__item-\").concat(countryCode));\n                            nextItem.setAttribute(\"aria-selected\", \"true\");\n                            nextItem.classList.add(\"iti__active\");\n                            this.activeItem = nextItem;\n                            this.selectedFlag.setAttribute(\"aria-activedescendant\", nextItem.getAttribute(\"id\"));\n                        }\n                    }\n                    // return if the flag has changed or not\n                    return prevCountry.iso2 !== countryCode;\n                }\n            }, {\n                key: \"_getHiddenSelectedFlagWidth\",\n                value: function _getHiddenSelectedFlagWidth() {\n                    // to get the right styling to apply, all we need is a shallow clone of the container,\n                    // and then to inject a deep clone of the selectedFlag element\n                    var containerClone = this.telInput.parentNode.cloneNode();\n                    containerClone.style.visibility = \"hidden\";\n                    document.body.appendChild(containerClone);\n                    var flagsContainerClone = this.flagsContainer.cloneNode();\n                    containerClone.appendChild(flagsContainerClone);\n                    var selectedFlagClone = this.selectedFlag.cloneNode(true);\n                    flagsContainerClone.appendChild(selectedFlagClone);\n                    var width = selectedFlagClone.offsetWidth;\n                    containerClone.parentNode.removeChild(containerClone);\n                    return width;\n                }\n            }, {\n                key: \"_updatePlaceholder\",\n                value: function _updatePlaceholder() {\n                    var shouldSetPlaceholder = this.options.autoPlaceholder === \"aggressive\" || !this.hadInitialPlaceholder && this.options.autoPlaceholder === \"polite\";\n                    if (window.intlTelInputUtils && shouldSetPlaceholder) {\n                        var numberType = intlTelInputUtils.numberType[this.options.placeholderNumberType];\n                        var placeholder = this.selectedCountryData.iso2 ? intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, this.options.nationalMode, numberType) : \"\";\n                        placeholder = this._beforeSetNumber(placeholder);\n                        if (typeof this.options.customPlaceholder === \"function\") {\n                            placeholder = this.options.customPlaceholder(placeholder, this.selectedCountryData);\n                        }\n                        this.telInput.setAttribute(\"placeholder\", placeholder);\n                    }\n                }\n            }, {\n                key: \"_selectListItem\",\n                value: function _selectListItem(listItem) {\n                    // update selected flag and active list item\n                    var flagChanged = this._setFlag(listItem.getAttribute(\"data-country-code\"));\n                    this._closeDropdown();\n                    this._updateDialCode(listItem.getAttribute(\"data-dial-code\"), true);\n                    // focus the input\n                    this.telInput.focus();\n                    // put cursor at end - this fix is required for FF and IE11 (with nationalMode=false i.e. auto\n                    // inserting dial code), who try to put the cursor at the beginning the first time\n                    var len = this.telInput.value.length;\n                    this.telInput.setSelectionRange(len, len);\n                    if (flagChanged) {\n                        this._triggerCountryChange();\n                    }\n                }\n            }, {\n                key: \"_closeDropdown\",\n                value: function _closeDropdown() {\n                    this.countryList.classList.add(\"iti__hide\");\n                    this.selectedFlag.setAttribute(\"aria-expanded\", \"false\");\n                    // update the arrow\n                    this.dropdownArrow.classList.remove(\"iti__arrow--up\");\n                    // unbind key events\n                    document.removeEventListener(\"keydown\", this._handleKeydownOnDropdown);\n                    document.documentElement.removeEventListener(\"click\", this._handleClickOffToClose);\n                    this.countryList.removeEventListener(\"mouseover\", this._handleMouseoverCountryList);\n                    this.countryList.removeEventListener(\"click\", this._handleClickCountryList);\n                    // remove menu from container\n                    if (this.options.dropdownContainer) {\n                        if (!this.isMobile) window.removeEventListener(\"scroll\", this._handleWindowScroll);\n                        if (this.dropdown.parentNode) this.dropdown.parentNode.removeChild(this.dropdown);\n                    }\n                    this._trigger(\"close:countrydropdown\");\n                }\n            }, {\n                key: \"_scrollTo\",\n                value: function _scrollTo(element, middle) {\n                    var container = this.countryList;\n                    // windowTop from https://stackoverflow.com/a/14384091/217866\n                    var windowTop = window.pageYOffset || document.documentElement.scrollTop;\n                    var containerHeight = container.offsetHeight;\n                    var containerTop = container.getBoundingClientRect().top + windowTop;\n                    var containerBottom = containerTop + containerHeight;\n                    var elementHeight = element.offsetHeight;\n                    var elementTop = element.getBoundingClientRect().top + windowTop;\n                    var elementBottom = elementTop + elementHeight;\n                    var newScrollTop = elementTop - containerTop + container.scrollTop;\n                    var middleOffset = containerHeight / 2 - elementHeight / 2;\n                    if (elementTop < containerTop) {\n                        // scroll up\n                        if (middle) newScrollTop -= middleOffset;\n                        container.scrollTop = newScrollTop;\n                    } else if (elementBottom > containerBottom) {\n                        // scroll down\n                        if (middle) newScrollTop += middleOffset;\n                        var heightDifference = containerHeight - elementHeight;\n                        container.scrollTop = newScrollTop - heightDifference;\n                    }\n                }\n            }, {\n                key: \"_updateDialCode\",\n                value: function _updateDialCode(newDialCodeBare, hasSelectedListItem) {\n                    var inputVal = this.telInput.value;\n                    // save having to pass this every time\n                    var newDialCode = \"+\".concat(newDialCodeBare);\n                    var newNumber;\n                    if (inputVal.charAt(0) === \"+\") {\n                        // there's a plus so we're dealing with a replacement (doesn't matter if nationalMode or not)\n                        var prevDialCode = this._getDialCode(inputVal);\n                        if (prevDialCode) {\n                            // current number contains a valid dial code, so replace it\n                            newNumber = inputVal.replace(prevDialCode, newDialCode);\n                        } else {\n                            // current number contains an invalid dial code, so ditch it\n                            // (no way to determine where the invalid dial code ends and the rest of the number begins)\n                            newNumber = newDialCode;\n                        }\n                    } else if (this.options.nationalMode || this.options.separateDialCode) {\n                        // don't do anything\n                        return;\n                    } else {\n                        // nationalMode is disabled\n                        if (inputVal) {\n                            // there is an existing value with no dial code: prefix the new dial code\n                            newNumber = newDialCode + inputVal;\n                        } else if (hasSelectedListItem || !this.options.autoHideDialCode) {\n                            // no existing value and either they've just selected a list item, or autoHideDialCode is\n                            // disabled: insert new dial code\n                            newNumber = newDialCode;\n                        } else {\n                            return;\n                        }\n                    }\n                    this.telInput.value = newNumber;\n                }\n            }, {\n                key: \"_getDialCode\",\n                value: function _getDialCode(number, includeAreaCode) {\n                    var dialCode = \"\";\n                    // only interested in international numbers (starting with a plus)\n                    if (number.charAt(0) === \"+\") {\n                        var numericChars = \"\";\n                        // iterate over chars\n                        for (var i = 0; i < number.length; i++) {\n                            var c = number.charAt(i);\n                            // if char is number (https://stackoverflow.com/a/8935649/217866)\n                            if (!isNaN(parseInt(c, 10))) {\n                                numericChars += c;\n                                // if current numericChars make a valid dial code\n                                if (includeAreaCode) {\n                                    if (this.countryCodes[numericChars]) {\n                                        // store the actual raw string (useful for matching later)\n                                        dialCode = number.substr(0, i + 1);\n                                    }\n                                } else {\n                                    if (this.dialCodes[numericChars]) {\n                                        dialCode = number.substr(0, i + 1);\n                                        // if we're just looking for a dial code, we can break as soon as we find one\n                                        break;\n                                    }\n                                }\n                                // stop searching as soon as we can - in this case when we hit max len\n                                if (numericChars.length === this.countryCodeMaxLen) {\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    return dialCode;\n                }\n            }, {\n                key: \"_getFullNumber\",\n                value: function _getFullNumber() {\n                    var val = this.telInput.value.trim();\n                    var dialCode = this.selectedCountryData.dialCode;\n                    var prefix;\n                    var numericVal = this._getNumeric(val);\n                    if (this.options.separateDialCode && val.charAt(0) !== \"+\" && dialCode && numericVal) {\n                        // when using separateDialCode, it is visible so is effectively part of the typed number\n                        prefix = \"+\".concat(dialCode);\n                    } else {\n                        prefix = \"\";\n                    }\n                    return prefix + val;\n                }\n            }, {\n                key: \"_beforeSetNumber\",\n                value: function _beforeSetNumber(originalNumber) {\n                    var number = originalNumber;\n                    if (this.options.separateDialCode) {\n                        var dialCode = this._getDialCode(number);\n                        // if there is a valid dial code\n                        if (dialCode) {\n                            // in case _getDialCode returned an area code as well\n                            dialCode = \"+\".concat(this.selectedCountryData.dialCode);\n                            // a lot of numbers will have a space separating the dial code and the main number, and\n                            // some NANP numbers will have a hyphen e.g. +1 684-733-1234 - in both cases we want to get\n                            // rid of it\n                            // NOTE: don't just trim all non-numerics as may want to preserve an open parenthesis etc\n                            var start = number[dialCode.length] === \" \" || number[dialCode.length] === \"-\" ? dialCode.length + 1 : dialCode.length;\n                            number = number.substr(start);\n                        }\n                    }\n                    return this._cap(number);\n                }\n            }, {\n                key: \"_triggerCountryChange\",\n                value: function _triggerCountryChange() {\n                    this._trigger(\"countrychange\");\n                }\n            }, {\n                key: \"handleAutoCountry\",\n                value: function handleAutoCountry() {\n                    if (this.options.initialCountry === \"auto\") {\n                        // we must set this even if there is an initial val in the input: in case the initial val is\n                        // invalid and they delete it - they should see their auto country\n                        this.defaultCountry = window.intlTelInputGlobals.autoCountry;\n                        // if there's no initial value in the input, then update the flag\n                        if (!this.telInput.value) {\n                            this.setCountry(this.defaultCountry);\n                        }\n                        this.resolveAutoCountryPromise();\n                    }\n                }\n            }, {\n                key: \"handleUtils\",\n                value: function handleUtils() {\n                    // if the request was successful\n                    if (window.intlTelInputUtils) {\n                        // if there's an initial value in the input, then format it\n                        if (this.telInput.value) {\n                            this._updateValFromNumber(this.telInput.value);\n                        }\n                        this._updatePlaceholder();\n                    }\n                    this.resolveUtilsScriptPromise();\n                }\n            }, {\n                key: \"destroy\",\n                value: function destroy() {\n                    var form = this.telInput.form;\n                    if (this.options.allowDropdown) {\n                        // make sure the dropdown is closed (and unbind listeners)\n                        this._closeDropdown();\n                        this.selectedFlag.removeEventListener(\"click\", this._handleClickSelectedFlag);\n                        this.flagsContainer.removeEventListener(\"keydown\", this._handleFlagsContainerKeydown);\n                        // label click hack\n                        var label = this._getClosestLabel();\n                        if (label) label.removeEventListener(\"click\", this._handleLabelClick);\n                    }\n                    // unbind hiddenInput listeners\n                    if (this.hiddenInput && form) form.removeEventListener(\"submit\", this._handleHiddenInputSubmit);\n                    // unbind autoHideDialCode listeners\n                    if (this.options.autoHideDialCode) {\n                        if (form) form.removeEventListener(\"submit\", this._handleSubmitOrBlurEvent);\n                        this.telInput.removeEventListener(\"blur\", this._handleSubmitOrBlurEvent);\n                    }\n                    // unbind key events, and cut/paste events\n                    this.telInput.removeEventListener(\"keyup\", this._handleKeyupEvent);\n                    this.telInput.removeEventListener(\"cut\", this._handleClipboardEvent);\n                    this.telInput.removeEventListener(\"paste\", this._handleClipboardEvent);\n                    // remove attribute of id instance: data-intl-tel-input-id\n                    this.telInput.removeAttribute(\"data-intl-tel-input-id\");\n                    // remove markup (but leave the original input)\n                    var wrapper = this.telInput.parentNode;\n                    wrapper.parentNode.insertBefore(this.telInput, wrapper);\n                    wrapper.parentNode.removeChild(wrapper);\n                    delete window.intlTelInputGlobals.instances[this.id];\n                }\n            }, {\n                key: \"getExtension\",\n                value: function getExtension() {\n                    if (window.intlTelInputUtils) {\n                        return intlTelInputUtils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2);\n                    }\n                    return \"\";\n                }\n            }, {\n                key: \"getNumber\",\n                value: function getNumber(format) {\n                    if (window.intlTelInputUtils) {\n                        var iso2 = this.selectedCountryData.iso2;\n                        return intlTelInputUtils.formatNumber(this._getFullNumber(), iso2, format);\n                    }\n                    return \"\";\n                }\n            }, {\n                key: \"getNumberType\",\n                value: function getNumberType() {\n                    if (window.intlTelInputUtils) {\n                        return intlTelInputUtils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2);\n                    }\n                    return -99;\n                }\n            }, {\n                key: \"getSelectedCountryData\",\n                value: function getSelectedCountryData() {\n                    return this.selectedCountryData;\n                }\n            }, {\n                key: \"getValidationError\",\n                value: function getValidationError() {\n                    if (window.intlTelInputUtils) {\n                        var iso2 = this.selectedCountryData.iso2;\n                        return intlTelInputUtils.getValidationError(this._getFullNumber(), iso2);\n                    }\n                    return -99;\n                }\n            }, {\n                key: \"isValidNumber\",\n                value: function isValidNumber() {\n                    var val = this._getFullNumber().trim();\n                    var countryCode = this.options.nationalMode ? this.selectedCountryData.iso2 : \"\";\n                    return window.intlTelInputUtils ? intlTelInputUtils.isValidNumber(val, countryCode) : null;\n                }\n            }, {\n                key: \"setCountry\",\n                value: function setCountry(originalCountryCode) {\n                    var countryCode = originalCountryCode.toLowerCase();\n                    // check if already selected\n                    if (!this.selectedFlagInner.classList.contains(\"iti__\".concat(countryCode))) {\n                        this._setFlag(countryCode);\n                        this._updateDialCode(this.selectedCountryData.dialCode, false);\n                        this._triggerCountryChange();\n                    }\n                }\n            }, {\n                key: \"setNumber\",\n                value: function setNumber(number) {\n                    // we must update the flag first, which updates this.selectedCountryData, which is used for\n                    // formatting the number before displaying it\n                    var flagChanged = this._updateFlagFromNumber(number);\n                    this._updateValFromNumber(number);\n                    if (flagChanged) {\n                        this._triggerCountryChange();\n                    }\n                }\n            }, {\n                key: \"setPlaceholderNumberType\",\n                value: function setPlaceholderNumberType(type) {\n                    this.options.placeholderNumberType = type;\n                    this._updatePlaceholder();\n                }\n            } ]);\n            return Iti;\n        }();\n        /********************\n *  STATIC METHODS\n ********************/\n        // get the country data object\n        intlTelInputGlobals.getCountryData = function() {\n            return allCountries;\n        };\n        // inject a <script> element to load utils.js\n        var injectScript = function injectScript(path, handleSuccess, handleFailure) {\n            // inject a new script element into the page\n            var script = document.createElement(\"script\");\n            script.onload = function() {\n                forEachInstance(\"handleUtils\");\n                if (handleSuccess) handleSuccess();\n            };\n            script.onerror = function() {\n                forEachInstance(\"rejectUtilsScriptPromise\");\n                if (handleFailure) handleFailure();\n            };\n            script.className = \"iti-load-utils\";\n            script.async = true;\n            script.src = path;\n            document.body.appendChild(script);\n        };\n        // load the utils script\n        intlTelInputGlobals.loadUtils = function(path) {\n            // 2 options:\n            // 1) not already started loading (start)\n            // 2) already started loading (do nothing - just wait for the onload callback to fire, which will\n            // trigger handleUtils on all instances, invoking their resolveUtilsScriptPromise functions)\n            if (!window.intlTelInputUtils && !window.intlTelInputGlobals.startedLoadingUtilsScript) {\n                // only do this once\n                window.intlTelInputGlobals.startedLoadingUtilsScript = true;\n                // if we have promises, then return a promise\n                if (typeof Promise !== \"undefined\") {\n                    return new Promise(function(resolve, reject) {\n                        return injectScript(path, resolve, reject);\n                    });\n                }\n                injectScript(path);\n            }\n            return null;\n        };\n        // default options\n        intlTelInputGlobals.defaults = defaults;\n        // version\n        intlTelInputGlobals.version = \"17.0.13\";\n        // convenience wrapper\n        return function(input, options) {\n            var iti = new Iti(input, options);\n            iti._init();\n            input.setAttribute(\"data-intl-tel-input-id\", iti.id);\n            window.intlTelInputGlobals.instances[iti.id] = iti;\n            return iti;\n        };\n    }();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW50bC10ZWwtaW5wdXQvYnVpbGQvanMvaW50bFRlbElucHV0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsS0FBMEIsZ0RBQWdEO0FBQ2xGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkNBQTJDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJCQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0Q0FBNEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHNCQUFzQjtBQUN0Qix5RkFBeUY7QUFDekY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSkFBZ0osc0RBQXNELHNEQUFzRDtBQUM1UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVFBhc3MvLi9ub2RlX21vZHVsZXMvaW50bC10ZWwtaW5wdXQvYnVpbGQvanMvaW50bFRlbElucHV0LmpzP2M4ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEludGVybmF0aW9uYWwgVGVsZXBob25lIElucHV0IHYxNy4wLjEzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vamFja29jbnIvaW50bC10ZWwtaW5wdXQuZ2l0XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuXG4vLyB3cmFwIGluIFVNRFxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7IGVsc2Ugd2luZG93LmludGxUZWxJbnB1dCA9IGZhY3RvcnkoKTtcbn0pKGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQXJyYXkgb2YgY291bnRyeSBvYmplY3RzIGZvciB0aGUgZmxhZyBkcm9wZG93bi5cbiAgICAgICAgLy8gSGVyZSBpcyB0aGUgY3JpdGVyaWEgZm9yIHRoZSBwbHVnaW4gdG8gc3VwcG9ydCBhIGdpdmVuIGNvdW50cnkvdGVycml0b3J5XG4gICAgICAgIC8vIC0gSXQgaGFzIGFuIGlzbzIgY29kZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzMxNjYtMV9hbHBoYS0yXG4gICAgICAgIC8vIC0gSXQgaGFzIGl0J3Mgb3duIGNvdW50cnkgY2FsbGluZyBjb2RlIChpdCBpcyBub3QgYSBzdWItcmVnaW9uIG9mIGFub3RoZXIgY291bnRyeSk6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfY291bnRyeV9jYWxsaW5nX2NvZGVzXG4gICAgICAgIC8vIC0gSXQgaGFzIGEgZmxhZyBpbiB0aGUgcmVnaW9uLWZsYWdzIHByb2plY3Q6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWhkYWQvcmVnaW9uLWZsYWdzL3RyZWUvZ2gtcGFnZXMvcG5nXG4gICAgICAgIC8vIC0gSXQgaXMgc3VwcG9ydGVkIGJ5IGxpYnBob25lbnVtYmVyIChpdCBtdXN0IGJlIGxpc3RlZCBvbiB0aGlzIHBhZ2UpOiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlaTE4bi9saWJwaG9uZW51bWJlci9ibG9iL21hc3Rlci9yZXNvdXJjZXMvU2hvcnROdW1iZXJNZXRhZGF0YS54bWxcbiAgICAgICAgLy8gRWFjaCBjb3VudHJ5IGFycmF5IGhhcyB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uOlxuICAgICAgICAvLyBbXG4gICAgICAgIC8vICAgIENvdW50cnkgbmFtZSxcbiAgICAgICAgLy8gICAgaXNvMiBjb2RlLFxuICAgICAgICAvLyAgICBJbnRlcm5hdGlvbmFsIGRpYWwgY29kZSxcbiAgICAgICAgLy8gICAgT3JkZXIgKGlmID4xIGNvdW50cnkgd2l0aCBzYW1lIGRpYWwgY29kZSksXG4gICAgICAgIC8vICAgIEFyZWEgY29kZXNcbiAgICAgICAgLy8gXVxuICAgICAgICB2YXIgYWxsQ291bnRyaWVzID0gWyBbIFwiQWZnaGFuaXN0YW4gKOKAq9in2YHYutin2YbYs9iq2KfZhuKArOKAjilcIiwgXCJhZlwiLCBcIjkzXCIgXSwgWyBcIkFsYmFuaWEgKFNocWlww6tyaSlcIiwgXCJhbFwiLCBcIjM1NVwiIF0sIFsgXCJBbGdlcmlhICjigKvYp9mE2KzYstin2KbYseKArOKAjilcIiwgXCJkelwiLCBcIjIxM1wiIF0sIFsgXCJBbWVyaWNhbiBTYW1vYVwiLCBcImFzXCIsIFwiMVwiLCA1LCBbIFwiNjg0XCIgXSBdLCBbIFwiQW5kb3JyYVwiLCBcImFkXCIsIFwiMzc2XCIgXSwgWyBcIkFuZ29sYVwiLCBcImFvXCIsIFwiMjQ0XCIgXSwgWyBcIkFuZ3VpbGxhXCIsIFwiYWlcIiwgXCIxXCIsIDYsIFsgXCIyNjRcIiBdIF0sIFsgXCJBbnRpZ3VhIGFuZCBCYXJidWRhXCIsIFwiYWdcIiwgXCIxXCIsIDcsIFsgXCIyNjhcIiBdIF0sIFsgXCJBcmdlbnRpbmFcIiwgXCJhclwiLCBcIjU0XCIgXSwgWyBcIkFybWVuaWEgKNWA1aHVtdWh1b3Vv9Wh1bYpXCIsIFwiYW1cIiwgXCIzNzRcIiBdLCBbIFwiQXJ1YmFcIiwgXCJhd1wiLCBcIjI5N1wiIF0sIFsgXCJBc2NlbnNpb24gSXNsYW5kXCIsIFwiYWNcIiwgXCIyNDdcIiBdLCBbIFwiQXVzdHJhbGlhXCIsIFwiYXVcIiwgXCI2MVwiLCAwIF0sIFsgXCJBdXN0cmlhICjDlnN0ZXJyZWljaClcIiwgXCJhdFwiLCBcIjQzXCIgXSwgWyBcIkF6ZXJiYWlqYW4gKEF6yZlyYmF5Y2FuKVwiLCBcImF6XCIsIFwiOTk0XCIgXSwgWyBcIkJhaGFtYXNcIiwgXCJic1wiLCBcIjFcIiwgOCwgWyBcIjI0MlwiIF0gXSwgWyBcIkJhaHJhaW4gKOKAq9in2YTYqNit2LHZitmG4oCs4oCOKVwiLCBcImJoXCIsIFwiOTczXCIgXSwgWyBcIkJhbmdsYWRlc2ggKOCmrOCmvuCmguCmsuCmvuCmpuCnh+CmtilcIiwgXCJiZFwiLCBcIjg4MFwiIF0sIFsgXCJCYXJiYWRvc1wiLCBcImJiXCIsIFwiMVwiLCA5LCBbIFwiMjQ2XCIgXSBdLCBbIFwiQmVsYXJ1cyAo0JHQtdC70LDRgNGD0YHRjClcIiwgXCJieVwiLCBcIjM3NVwiIF0sIFsgXCJCZWxnaXVtIChCZWxnacOrKVwiLCBcImJlXCIsIFwiMzJcIiBdLCBbIFwiQmVsaXplXCIsIFwiYnpcIiwgXCI1MDFcIiBdLCBbIFwiQmVuaW4gKELDqW5pbilcIiwgXCJialwiLCBcIjIyOVwiIF0sIFsgXCJCZXJtdWRhXCIsIFwiYm1cIiwgXCIxXCIsIDEwLCBbIFwiNDQxXCIgXSBdLCBbIFwiQmh1dGFuICjgvaDgvZbgvrLgvbTgvYIpXCIsIFwiYnRcIiwgXCI5NzVcIiBdLCBbIFwiQm9saXZpYVwiLCBcImJvXCIsIFwiNTkxXCIgXSwgWyBcIkJvc25pYSBhbmQgSGVyemVnb3ZpbmEgKNCR0L7RgdC90LAg0Lgg0KXQtdGA0YbQtdCz0L7QstC40L3QsClcIiwgXCJiYVwiLCBcIjM4N1wiIF0sIFsgXCJCb3Rzd2FuYVwiLCBcImJ3XCIsIFwiMjY3XCIgXSwgWyBcIkJyYXppbCAoQnJhc2lsKVwiLCBcImJyXCIsIFwiNTVcIiBdLCBbIFwiQnJpdGlzaCBJbmRpYW4gT2NlYW4gVGVycml0b3J5XCIsIFwiaW9cIiwgXCIyNDZcIiBdLCBbIFwiQnJpdGlzaCBWaXJnaW4gSXNsYW5kc1wiLCBcInZnXCIsIFwiMVwiLCAxMSwgWyBcIjI4NFwiIF0gXSwgWyBcIkJydW5laVwiLCBcImJuXCIsIFwiNjczXCIgXSwgWyBcIkJ1bGdhcmlhICjQkdGK0LvQs9Cw0YDQuNGPKVwiLCBcImJnXCIsIFwiMzU5XCIgXSwgWyBcIkJ1cmtpbmEgRmFzb1wiLCBcImJmXCIsIFwiMjI2XCIgXSwgWyBcIkJ1cnVuZGkgKFVidXJ1bmRpKVwiLCBcImJpXCIsIFwiMjU3XCIgXSwgWyBcIkNhbWJvZGlhICjhnoDhnpjhn5LhnpbhnrvhnofhnrYpXCIsIFwia2hcIiwgXCI4NTVcIiBdLCBbIFwiQ2FtZXJvb24gKENhbWVyb3VuKVwiLCBcImNtXCIsIFwiMjM3XCIgXSwgWyBcIkNhbmFkYVwiLCBcImNhXCIsIFwiMVwiLCAxLCBbIFwiMjA0XCIsIFwiMjI2XCIsIFwiMjM2XCIsIFwiMjQ5XCIsIFwiMjUwXCIsIFwiMjg5XCIsIFwiMzA2XCIsIFwiMzQzXCIsIFwiMzY1XCIsIFwiMzg3XCIsIFwiNDAzXCIsIFwiNDE2XCIsIFwiNDE4XCIsIFwiNDMxXCIsIFwiNDM3XCIsIFwiNDM4XCIsIFwiNDUwXCIsIFwiNTA2XCIsIFwiNTE0XCIsIFwiNTE5XCIsIFwiNTQ4XCIsIFwiNTc5XCIsIFwiNTgxXCIsIFwiNTg3XCIsIFwiNjA0XCIsIFwiNjEzXCIsIFwiNjM5XCIsIFwiNjQ3XCIsIFwiNjcyXCIsIFwiNzA1XCIsIFwiNzA5XCIsIFwiNzQyXCIsIFwiNzc4XCIsIFwiNzgwXCIsIFwiNzgyXCIsIFwiODA3XCIsIFwiODE5XCIsIFwiODI1XCIsIFwiODY3XCIsIFwiODczXCIsIFwiOTAyXCIsIFwiOTA1XCIgXSBdLCBbIFwiQ2FwZSBWZXJkZSAoS2FidSBWZXJkaSlcIiwgXCJjdlwiLCBcIjIzOFwiIF0sIFsgXCJDYXJpYmJlYW4gTmV0aGVybGFuZHNcIiwgXCJicVwiLCBcIjU5OVwiLCAxLCBbIFwiM1wiLCBcIjRcIiwgXCI3XCIgXSBdLCBbIFwiQ2F5bWFuIElzbGFuZHNcIiwgXCJreVwiLCBcIjFcIiwgMTIsIFsgXCIzNDVcIiBdIF0sIFsgXCJDZW50cmFsIEFmcmljYW4gUmVwdWJsaWMgKFLDqXB1YmxpcXVlIGNlbnRyYWZyaWNhaW5lKVwiLCBcImNmXCIsIFwiMjM2XCIgXSwgWyBcIkNoYWQgKFRjaGFkKVwiLCBcInRkXCIsIFwiMjM1XCIgXSwgWyBcIkNoaWxlXCIsIFwiY2xcIiwgXCI1NlwiIF0sIFsgXCJDaGluYSAo5Lit5Zu9KVwiLCBcImNuXCIsIFwiODZcIiBdLCBbIFwiQ2hyaXN0bWFzIElzbGFuZFwiLCBcImN4XCIsIFwiNjFcIiwgMiwgWyBcIjg5MTY0XCIgXSBdLCBbIFwiQ29jb3MgKEtlZWxpbmcpIElzbGFuZHNcIiwgXCJjY1wiLCBcIjYxXCIsIDEsIFsgXCI4OTE2MlwiIF0gXSwgWyBcIkNvbG9tYmlhXCIsIFwiY29cIiwgXCI1N1wiIF0sIFsgXCJDb21vcm9zICjigKvYrNiy2LEg2KfZhNmC2YXYseKArOKAjilcIiwgXCJrbVwiLCBcIjI2OVwiIF0sIFsgXCJDb25nbyAoRFJDKSAoSmFtaHVyaSB5YSBLaWRlbW9rcmFzaWEgeWEgS29uZ28pXCIsIFwiY2RcIiwgXCIyNDNcIiBdLCBbIFwiQ29uZ28gKFJlcHVibGljKSAoQ29uZ28tQnJhenphdmlsbGUpXCIsIFwiY2dcIiwgXCIyNDJcIiBdLCBbIFwiQ29vayBJc2xhbmRzXCIsIFwiY2tcIiwgXCI2ODJcIiBdLCBbIFwiQ29zdGEgUmljYVwiLCBcImNyXCIsIFwiNTA2XCIgXSwgWyBcIkPDtHRlIGTigJlJdm9pcmVcIiwgXCJjaVwiLCBcIjIyNVwiIF0sIFsgXCJDcm9hdGlhIChIcnZhdHNrYSlcIiwgXCJoclwiLCBcIjM4NVwiIF0sIFsgXCJDdWJhXCIsIFwiY3VcIiwgXCI1M1wiIF0sIFsgXCJDdXJhw6dhb1wiLCBcImN3XCIsIFwiNTk5XCIsIDAgXSwgWyBcIkN5cHJ1cyAozprPjc+Az4HOv8+CKVwiLCBcImN5XCIsIFwiMzU3XCIgXSwgWyBcIkN6ZWNoIFJlcHVibGljICjEjGVza8OhIHJlcHVibGlrYSlcIiwgXCJjelwiLCBcIjQyMFwiIF0sIFsgXCJEZW5tYXJrIChEYW5tYXJrKVwiLCBcImRrXCIsIFwiNDVcIiBdLCBbIFwiRGppYm91dGlcIiwgXCJkalwiLCBcIjI1M1wiIF0sIFsgXCJEb21pbmljYVwiLCBcImRtXCIsIFwiMVwiLCAxMywgWyBcIjc2N1wiIF0gXSwgWyBcIkRvbWluaWNhbiBSZXB1YmxpYyAoUmVww7pibGljYSBEb21pbmljYW5hKVwiLCBcImRvXCIsIFwiMVwiLCAyLCBbIFwiODA5XCIsIFwiODI5XCIsIFwiODQ5XCIgXSBdLCBbIFwiRWN1YWRvclwiLCBcImVjXCIsIFwiNTkzXCIgXSwgWyBcIkVneXB0ICjigKvZhdi12LHigKzigI4pXCIsIFwiZWdcIiwgXCIyMFwiIF0sIFsgXCJFbCBTYWx2YWRvclwiLCBcInN2XCIsIFwiNTAzXCIgXSwgWyBcIkVxdWF0b3JpYWwgR3VpbmVhIChHdWluZWEgRWN1YXRvcmlhbClcIiwgXCJncVwiLCBcIjI0MFwiIF0sIFsgXCJFcml0cmVhXCIsIFwiZXJcIiwgXCIyOTFcIiBdLCBbIFwiRXN0b25pYSAoRWVzdGkpXCIsIFwiZWVcIiwgXCIzNzJcIiBdLCBbIFwiRXN3YXRpbmlcIiwgXCJzelwiLCBcIjI2OFwiIF0sIFsgXCJFdGhpb3BpYVwiLCBcImV0XCIsIFwiMjUxXCIgXSwgWyBcIkZhbGtsYW5kIElzbGFuZHMgKElzbGFzIE1hbHZpbmFzKVwiLCBcImZrXCIsIFwiNTAwXCIgXSwgWyBcIkZhcm9lIElzbGFuZHMgKEbDuHJveWFyKVwiLCBcImZvXCIsIFwiMjk4XCIgXSwgWyBcIkZpamlcIiwgXCJmalwiLCBcIjY3OVwiIF0sIFsgXCJGaW5sYW5kIChTdW9taSlcIiwgXCJmaVwiLCBcIjM1OFwiLCAwIF0sIFsgXCJGcmFuY2VcIiwgXCJmclwiLCBcIjMzXCIgXSwgWyBcIkZyZW5jaCBHdWlhbmEgKEd1eWFuZSBmcmFuw6dhaXNlKVwiLCBcImdmXCIsIFwiNTk0XCIgXSwgWyBcIkZyZW5jaCBQb2x5bmVzaWEgKFBvbHluw6lzaWUgZnJhbsOnYWlzZSlcIiwgXCJwZlwiLCBcIjY4OVwiIF0sIFsgXCJHYWJvblwiLCBcImdhXCIsIFwiMjQxXCIgXSwgWyBcIkdhbWJpYVwiLCBcImdtXCIsIFwiMjIwXCIgXSwgWyBcIkdlb3JnaWEgKOGDoeGDkOGDpeGDkOGDoOGDl+GDleGDlOGDmuGDnSlcIiwgXCJnZVwiLCBcIjk5NVwiIF0sIFsgXCJHZXJtYW55IChEZXV0c2NobGFuZClcIiwgXCJkZVwiLCBcIjQ5XCIgXSwgWyBcIkdoYW5hIChHYWFuYSlcIiwgXCJnaFwiLCBcIjIzM1wiIF0sIFsgXCJHaWJyYWx0YXJcIiwgXCJnaVwiLCBcIjM1MFwiIF0sIFsgXCJHcmVlY2UgKM6VzrvOu86szrTOsSlcIiwgXCJnclwiLCBcIjMwXCIgXSwgWyBcIkdyZWVubGFuZCAoS2FsYWFsbGl0IE51bmFhdClcIiwgXCJnbFwiLCBcIjI5OVwiIF0sIFsgXCJHcmVuYWRhXCIsIFwiZ2RcIiwgXCIxXCIsIDE0LCBbIFwiNDczXCIgXSBdLCBbIFwiR3VhZGVsb3VwZVwiLCBcImdwXCIsIFwiNTkwXCIsIDAgXSwgWyBcIkd1YW1cIiwgXCJndVwiLCBcIjFcIiwgMTUsIFsgXCI2NzFcIiBdIF0sIFsgXCJHdWF0ZW1hbGFcIiwgXCJndFwiLCBcIjUwMlwiIF0sIFsgXCJHdWVybnNleVwiLCBcImdnXCIsIFwiNDRcIiwgMSwgWyBcIjE0ODFcIiwgXCI3NzgxXCIsIFwiNzgzOVwiLCBcIjc5MTFcIiBdIF0sIFsgXCJHdWluZWEgKEd1aW7DqWUpXCIsIFwiZ25cIiwgXCIyMjRcIiBdLCBbIFwiR3VpbmVhLUJpc3NhdSAoR3VpbsOpIEJpc3NhdSlcIiwgXCJnd1wiLCBcIjI0NVwiIF0sIFsgXCJHdXlhbmFcIiwgXCJneVwiLCBcIjU5MlwiIF0sIFsgXCJIYWl0aVwiLCBcImh0XCIsIFwiNTA5XCIgXSwgWyBcIkhvbmR1cmFzXCIsIFwiaG5cIiwgXCI1MDRcIiBdLCBbIFwiSG9uZyBLb25nICjpppnmuK8pXCIsIFwiaGtcIiwgXCI4NTJcIiBdLCBbIFwiSHVuZ2FyeSAoTWFneWFyb3JzesOhZylcIiwgXCJodVwiLCBcIjM2XCIgXSwgWyBcIkljZWxhbmQgKMONc2xhbmQpXCIsIFwiaXNcIiwgXCIzNTRcIiBdLCBbIFwiSW5kaWEgKOCkreCkvuCksOCkpClcIiwgXCJpblwiLCBcIjkxXCIgXSwgWyBcIkluZG9uZXNpYVwiLCBcImlkXCIsIFwiNjJcIiBdLCBbIFwiSXJhbiAo4oCr2KfbjNix2KfZhuKArOKAjilcIiwgXCJpclwiLCBcIjk4XCIgXSwgWyBcIklyYXEgKOKAq9in2YTYudix2KfZguKArOKAjilcIiwgXCJpcVwiLCBcIjk2NFwiIF0sIFsgXCJJcmVsYW5kXCIsIFwiaWVcIiwgXCIzNTNcIiBdLCBbIFwiSXNsZSBvZiBNYW5cIiwgXCJpbVwiLCBcIjQ0XCIsIDIsIFsgXCIxNjI0XCIsIFwiNzQ1NzZcIiwgXCI3NTI0XCIsIFwiNzkyNFwiLCBcIjc2MjRcIiBdIF0sIFsgXCJJc3JhZWwgKOKAq9eZ16nXqNeQ15zigKzigI4pXCIsIFwiaWxcIiwgXCI5NzJcIiBdLCBbIFwiSXRhbHkgKEl0YWxpYSlcIiwgXCJpdFwiLCBcIjM5XCIsIDAgXSwgWyBcIkphbWFpY2FcIiwgXCJqbVwiLCBcIjFcIiwgNCwgWyBcIjg3NlwiLCBcIjY1OFwiIF0gXSwgWyBcIkphcGFuICjml6XmnKwpXCIsIFwianBcIiwgXCI4MVwiIF0sIFsgXCJKZXJzZXlcIiwgXCJqZVwiLCBcIjQ0XCIsIDMsIFsgXCIxNTM0XCIsIFwiNzUwOVwiLCBcIjc3MDBcIiwgXCI3Nzk3XCIsIFwiNzgyOVwiLCBcIjc5MzdcIiBdIF0sIFsgXCJKb3JkYW4gKOKAq9in2YTYo9ix2K/ZhuKArOKAjilcIiwgXCJqb1wiLCBcIjk2MlwiIF0sIFsgXCJLYXpha2hzdGFuICjQmtCw0LfQsNGF0YHRgtCw0L0pXCIsIFwia3pcIiwgXCI3XCIsIDEsIFsgXCIzM1wiLCBcIjdcIiBdIF0sIFsgXCJLZW55YVwiLCBcImtlXCIsIFwiMjU0XCIgXSwgWyBcIktpcmliYXRpXCIsIFwia2lcIiwgXCI2ODZcIiBdLCBbIFwiS29zb3ZvXCIsIFwieGtcIiwgXCIzODNcIiBdLCBbIFwiS3V3YWl0ICjigKvYp9mE2YPZiNmK2KrigKzigI4pXCIsIFwia3dcIiwgXCI5NjVcIiBdLCBbIFwiS3lyZ3l6c3RhbiAo0JrRi9GA0LPRi9C30YHRgtCw0L0pXCIsIFwia2dcIiwgXCI5OTZcIiBdLCBbIFwiTGFvcyAo4Lql4Lqy4LqnKVwiLCBcImxhXCIsIFwiODU2XCIgXSwgWyBcIkxhdHZpYSAoTGF0dmlqYSlcIiwgXCJsdlwiLCBcIjM3MVwiIF0sIFsgXCJMZWJhbm9uICjigKvZhNio2YbYp9mG4oCs4oCOKVwiLCBcImxiXCIsIFwiOTYxXCIgXSwgWyBcIkxlc290aG9cIiwgXCJsc1wiLCBcIjI2NlwiIF0sIFsgXCJMaWJlcmlhXCIsIFwibHJcIiwgXCIyMzFcIiBdLCBbIFwiTGlieWEgKOKAq9mE2YrYqNmK2KfigKzigI4pXCIsIFwibHlcIiwgXCIyMThcIiBdLCBbIFwiTGllY2h0ZW5zdGVpblwiLCBcImxpXCIsIFwiNDIzXCIgXSwgWyBcIkxpdGh1YW5pYSAoTGlldHV2YSlcIiwgXCJsdFwiLCBcIjM3MFwiIF0sIFsgXCJMdXhlbWJvdXJnXCIsIFwibHVcIiwgXCIzNTJcIiBdLCBbIFwiTWFjYXUgKOa+s+mWgClcIiwgXCJtb1wiLCBcIjg1M1wiIF0sIFsgXCJNYWNlZG9uaWEgKEZZUk9NKSAo0JzQsNC60LXQtNC+0L3QuNGY0LApXCIsIFwibWtcIiwgXCIzODlcIiBdLCBbIFwiTWFkYWdhc2NhciAoTWFkYWdhc2lrYXJhKVwiLCBcIm1nXCIsIFwiMjYxXCIgXSwgWyBcIk1hbGF3aVwiLCBcIm13XCIsIFwiMjY1XCIgXSwgWyBcIk1hbGF5c2lhXCIsIFwibXlcIiwgXCI2MFwiIF0sIFsgXCJNYWxkaXZlc1wiLCBcIm12XCIsIFwiOTYwXCIgXSwgWyBcIk1hbGlcIiwgXCJtbFwiLCBcIjIyM1wiIF0sIFsgXCJNYWx0YVwiLCBcIm10XCIsIFwiMzU2XCIgXSwgWyBcIk1hcnNoYWxsIElzbGFuZHNcIiwgXCJtaFwiLCBcIjY5MlwiIF0sIFsgXCJNYXJ0aW5pcXVlXCIsIFwibXFcIiwgXCI1OTZcIiBdLCBbIFwiTWF1cml0YW5pYSAo4oCr2YXZiNix2YrYqtin2YbZitin4oCs4oCOKVwiLCBcIm1yXCIsIFwiMjIyXCIgXSwgWyBcIk1hdXJpdGl1cyAoTW9yaXMpXCIsIFwibXVcIiwgXCIyMzBcIiBdLCBbIFwiTWF5b3R0ZVwiLCBcInl0XCIsIFwiMjYyXCIsIDEsIFsgXCIyNjlcIiwgXCI2MzlcIiBdIF0sIFsgXCJNZXhpY28gKE3DqXhpY28pXCIsIFwibXhcIiwgXCI1MlwiIF0sIFsgXCJNaWNyb25lc2lhXCIsIFwiZm1cIiwgXCI2OTFcIiBdLCBbIFwiTW9sZG92YSAoUmVwdWJsaWNhIE1vbGRvdmEpXCIsIFwibWRcIiwgXCIzNzNcIiBdLCBbIFwiTW9uYWNvXCIsIFwibWNcIiwgXCIzNzdcIiBdLCBbIFwiTW9uZ29saWEgKNCc0L7QvdCz0L7QuylcIiwgXCJtblwiLCBcIjk3NlwiIF0sIFsgXCJNb250ZW5lZ3JvIChDcm5hIEdvcmEpXCIsIFwibWVcIiwgXCIzODJcIiBdLCBbIFwiTW9udHNlcnJhdFwiLCBcIm1zXCIsIFwiMVwiLCAxNiwgWyBcIjY2NFwiIF0gXSwgWyBcIk1vcm9jY28gKOKAq9in2YTZhdi62LHYqOKArOKAjilcIiwgXCJtYVwiLCBcIjIxMlwiLCAwIF0sIFsgXCJNb3phbWJpcXVlIChNb8OnYW1iaXF1ZSlcIiwgXCJtelwiLCBcIjI1OFwiIF0sIFsgXCJNeWFubWFyIChCdXJtYSkgKOGAmeGAvOGAlOGAuuGAmeGArClcIiwgXCJtbVwiLCBcIjk1XCIgXSwgWyBcIk5hbWliaWEgKE5hbWliacOrKVwiLCBcIm5hXCIsIFwiMjY0XCIgXSwgWyBcIk5hdXJ1XCIsIFwibnJcIiwgXCI2NzRcIiBdLCBbIFwiTmVwYWwgKOCkqOClh+CkquCkvuCksilcIiwgXCJucFwiLCBcIjk3N1wiIF0sIFsgXCJOZXRoZXJsYW5kcyAoTmVkZXJsYW5kKVwiLCBcIm5sXCIsIFwiMzFcIiBdLCBbIFwiTmV3IENhbGVkb25pYSAoTm91dmVsbGUtQ2Fsw6lkb25pZSlcIiwgXCJuY1wiLCBcIjY4N1wiIF0sIFsgXCJOZXcgWmVhbGFuZFwiLCBcIm56XCIsIFwiNjRcIiBdLCBbIFwiTmljYXJhZ3VhXCIsIFwibmlcIiwgXCI1MDVcIiBdLCBbIFwiTmlnZXIgKE5pamFyKVwiLCBcIm5lXCIsIFwiMjI3XCIgXSwgWyBcIk5pZ2VyaWFcIiwgXCJuZ1wiLCBcIjIzNFwiIF0sIFsgXCJOaXVlXCIsIFwibnVcIiwgXCI2ODNcIiBdLCBbIFwiTm9yZm9sayBJc2xhbmRcIiwgXCJuZlwiLCBcIjY3MlwiIF0sIFsgXCJOb3J0aCBLb3JlYSAo7KGw7ISgIOuvvOyjvOyjvOydmCDsnbjrr7wg6rO17ZmU6rWtKVwiLCBcImtwXCIsIFwiODUwXCIgXSwgWyBcIk5vcnRoZXJuIE1hcmlhbmEgSXNsYW5kc1wiLCBcIm1wXCIsIFwiMVwiLCAxNywgWyBcIjY3MFwiIF0gXSwgWyBcIk5vcndheSAoTm9yZ2UpXCIsIFwibm9cIiwgXCI0N1wiLCAwIF0sIFsgXCJPbWFuICjigKvYudmP2YXYp9mG4oCs4oCOKVwiLCBcIm9tXCIsIFwiOTY4XCIgXSwgWyBcIlBha2lzdGFuICjigKvZvtin2qnYs9iq2KfZhuKArOKAjilcIiwgXCJwa1wiLCBcIjkyXCIgXSwgWyBcIlBhbGF1XCIsIFwicHdcIiwgXCI2ODBcIiBdLCBbIFwiUGFsZXN0aW5lICjigKvZgdmE2LPYt9mK2YbigKzigI4pXCIsIFwicHNcIiwgXCI5NzBcIiBdLCBbIFwiUGFuYW1hIChQYW5hbcOhKVwiLCBcInBhXCIsIFwiNTA3XCIgXSwgWyBcIlBhcHVhIE5ldyBHdWluZWFcIiwgXCJwZ1wiLCBcIjY3NVwiIF0sIFsgXCJQYXJhZ3VheVwiLCBcInB5XCIsIFwiNTk1XCIgXSwgWyBcIlBlcnUgKFBlcsO6KVwiLCBcInBlXCIsIFwiNTFcIiBdLCBbIFwiUGhpbGlwcGluZXNcIiwgXCJwaFwiLCBcIjYzXCIgXSwgWyBcIlBvbGFuZCAoUG9sc2thKVwiLCBcInBsXCIsIFwiNDhcIiBdLCBbIFwiUG9ydHVnYWxcIiwgXCJwdFwiLCBcIjM1MVwiIF0sIFsgXCJQdWVydG8gUmljb1wiLCBcInByXCIsIFwiMVwiLCAzLCBbIFwiNzg3XCIsIFwiOTM5XCIgXSBdLCBbIFwiUWF0YXIgKOKAq9mC2LfYseKArOKAjilcIiwgXCJxYVwiLCBcIjk3NFwiIF0sIFsgXCJSw6l1bmlvbiAoTGEgUsOpdW5pb24pXCIsIFwicmVcIiwgXCIyNjJcIiwgMCBdLCBbIFwiUm9tYW5pYSAoUm9tw6JuaWEpXCIsIFwicm9cIiwgXCI0MFwiIF0sIFsgXCJSdXNzaWEgKNCg0L7RgdGB0LjRjylcIiwgXCJydVwiLCBcIjdcIiwgMCBdLCBbIFwiUndhbmRhXCIsIFwicndcIiwgXCIyNTBcIiBdLCBbIFwiU2FpbnQgQmFydGjDqWxlbXlcIiwgXCJibFwiLCBcIjU5MFwiLCAxIF0sIFsgXCJTYWludCBIZWxlbmFcIiwgXCJzaFwiLCBcIjI5MFwiIF0sIFsgXCJTYWludCBLaXR0cyBhbmQgTmV2aXNcIiwgXCJrblwiLCBcIjFcIiwgMTgsIFsgXCI4NjlcIiBdIF0sIFsgXCJTYWludCBMdWNpYVwiLCBcImxjXCIsIFwiMVwiLCAxOSwgWyBcIjc1OFwiIF0gXSwgWyBcIlNhaW50IE1hcnRpbiAoU2FpbnQtTWFydGluIChwYXJ0aWUgZnJhbsOnYWlzZSkpXCIsIFwibWZcIiwgXCI1OTBcIiwgMiBdLCBbIFwiU2FpbnQgUGllcnJlIGFuZCBNaXF1ZWxvbiAoU2FpbnQtUGllcnJlLWV0LU1pcXVlbG9uKVwiLCBcInBtXCIsIFwiNTA4XCIgXSwgWyBcIlNhaW50IFZpbmNlbnQgYW5kIHRoZSBHcmVuYWRpbmVzXCIsIFwidmNcIiwgXCIxXCIsIDIwLCBbIFwiNzg0XCIgXSBdLCBbIFwiU2Ftb2FcIiwgXCJ3c1wiLCBcIjY4NVwiIF0sIFsgXCJTYW4gTWFyaW5vXCIsIFwic21cIiwgXCIzNzhcIiBdLCBbIFwiU8OjbyBUb23DqSBhbmQgUHLDrW5jaXBlIChTw6NvIFRvbcOpIGUgUHLDrW5jaXBlKVwiLCBcInN0XCIsIFwiMjM5XCIgXSwgWyBcIlNhdWRpIEFyYWJpYSAo4oCr2KfZhNmF2YXZhNmD2Kkg2KfZhNi52LHYqNmK2Kkg2KfZhNiz2LnZiNiv2YrYqeKArOKAjilcIiwgXCJzYVwiLCBcIjk2NlwiIF0sIFsgXCJTZW5lZ2FsIChTw6luw6lnYWwpXCIsIFwic25cIiwgXCIyMjFcIiBdLCBbIFwiU2VyYmlhICjQodGA0LHQuNGY0LApXCIsIFwicnNcIiwgXCIzODFcIiBdLCBbIFwiU2V5Y2hlbGxlc1wiLCBcInNjXCIsIFwiMjQ4XCIgXSwgWyBcIlNpZXJyYSBMZW9uZVwiLCBcInNsXCIsIFwiMjMyXCIgXSwgWyBcIlNpbmdhcG9yZVwiLCBcInNnXCIsIFwiNjVcIiBdLCBbIFwiU2ludCBNYWFydGVuXCIsIFwic3hcIiwgXCIxXCIsIDIxLCBbIFwiNzIxXCIgXSBdLCBbIFwiU2xvdmFraWEgKFNsb3ZlbnNrbylcIiwgXCJza1wiLCBcIjQyMVwiIF0sIFsgXCJTbG92ZW5pYSAoU2xvdmVuaWphKVwiLCBcInNpXCIsIFwiMzg2XCIgXSwgWyBcIlNvbG9tb24gSXNsYW5kc1wiLCBcInNiXCIsIFwiNjc3XCIgXSwgWyBcIlNvbWFsaWEgKFNvb21hYWxpeWEpXCIsIFwic29cIiwgXCIyNTJcIiBdLCBbIFwiU291dGggQWZyaWNhXCIsIFwiemFcIiwgXCIyN1wiIF0sIFsgXCJTb3V0aCBLb3JlYSAo64yA7ZWc66+86rWtKVwiLCBcImtyXCIsIFwiODJcIiBdLCBbIFwiU291dGggU3VkYW4gKOKAq9is2YbZiNioINin2YTYs9mI2K/Yp9mG4oCs4oCOKVwiLCBcInNzXCIsIFwiMjExXCIgXSwgWyBcIlNwYWluIChFc3Bhw7FhKVwiLCBcImVzXCIsIFwiMzRcIiBdLCBbIFwiU3JpIExhbmthICjgt4Hgt4rigI3gtrvgt5Mg4La94LaC4Laa4LeP4LeAKVwiLCBcImxrXCIsIFwiOTRcIiBdLCBbIFwiU3VkYW4gKOKAq9in2YTYs9mI2K/Yp9mG4oCs4oCOKVwiLCBcInNkXCIsIFwiMjQ5XCIgXSwgWyBcIlN1cmluYW1lXCIsIFwic3JcIiwgXCI1OTdcIiBdLCBbIFwiU3ZhbGJhcmQgYW5kIEphbiBNYXllblwiLCBcInNqXCIsIFwiNDdcIiwgMSwgWyBcIjc5XCIgXSBdLCBbIFwiU3dlZGVuIChTdmVyaWdlKVwiLCBcInNlXCIsIFwiNDZcIiBdLCBbIFwiU3dpdHplcmxhbmQgKFNjaHdlaXopXCIsIFwiY2hcIiwgXCI0MVwiIF0sIFsgXCJTeXJpYSAo4oCr2LPZiNix2YrYp+KArOKAjilcIiwgXCJzeVwiLCBcIjk2M1wiIF0sIFsgXCJUYWl3YW4gKOWPsOeBoylcIiwgXCJ0d1wiLCBcIjg4NlwiIF0sIFsgXCJUYWppa2lzdGFuXCIsIFwidGpcIiwgXCI5OTJcIiBdLCBbIFwiVGFuemFuaWFcIiwgXCJ0elwiLCBcIjI1NVwiIF0sIFsgXCJUaGFpbGFuZCAo4LmE4LiX4LiiKVwiLCBcInRoXCIsIFwiNjZcIiBdLCBbIFwiVGltb3ItTGVzdGVcIiwgXCJ0bFwiLCBcIjY3MFwiIF0sIFsgXCJUb2dvXCIsIFwidGdcIiwgXCIyMjhcIiBdLCBbIFwiVG9rZWxhdVwiLCBcInRrXCIsIFwiNjkwXCIgXSwgWyBcIlRvbmdhXCIsIFwidG9cIiwgXCI2NzZcIiBdLCBbIFwiVHJpbmlkYWQgYW5kIFRvYmFnb1wiLCBcInR0XCIsIFwiMVwiLCAyMiwgWyBcIjg2OFwiIF0gXSwgWyBcIlR1bmlzaWEgKOKAq9iq2YjZhtiz4oCs4oCOKVwiLCBcInRuXCIsIFwiMjE2XCIgXSwgWyBcIlR1cmtleSAoVMO8cmtpeWUpXCIsIFwidHJcIiwgXCI5MFwiIF0sIFsgXCJUdXJrbWVuaXN0YW5cIiwgXCJ0bVwiLCBcIjk5M1wiIF0sIFsgXCJUdXJrcyBhbmQgQ2FpY29zIElzbGFuZHNcIiwgXCJ0Y1wiLCBcIjFcIiwgMjMsIFsgXCI2NDlcIiBdIF0sIFsgXCJUdXZhbHVcIiwgXCJ0dlwiLCBcIjY4OFwiIF0sIFsgXCJVLlMuIFZpcmdpbiBJc2xhbmRzXCIsIFwidmlcIiwgXCIxXCIsIDI0LCBbIFwiMzQwXCIgXSBdLCBbIFwiVWdhbmRhXCIsIFwidWdcIiwgXCIyNTZcIiBdLCBbIFwiVWtyYWluZSAo0KPQutGA0LDRl9C90LApXCIsIFwidWFcIiwgXCIzODBcIiBdLCBbIFwiVW5pdGVkIEFyYWIgRW1pcmF0ZXMgKOKAq9in2YTYpdmF2KfYsdin2Kog2KfZhNi52LHYqNmK2Kkg2KfZhNmF2KrYrdiv2KnigKzigI4pXCIsIFwiYWVcIiwgXCI5NzFcIiBdLCBbIFwiVW5pdGVkIEtpbmdkb21cIiwgXCJnYlwiLCBcIjQ0XCIsIDAgXSwgWyBcIlVuaXRlZCBTdGF0ZXNcIiwgXCJ1c1wiLCBcIjFcIiwgMCBdLCBbIFwiVXJ1Z3VheVwiLCBcInV5XCIsIFwiNTk4XCIgXSwgWyBcIlV6YmVraXN0YW4gKE/Ku3piZWtpc3RvbilcIiwgXCJ1elwiLCBcIjk5OFwiIF0sIFsgXCJWYW51YXR1XCIsIFwidnVcIiwgXCI2NzhcIiBdLCBbIFwiVmF0aWNhbiBDaXR5IChDaXR0w6AgZGVsIFZhdGljYW5vKVwiLCBcInZhXCIsIFwiMzlcIiwgMSwgWyBcIjA2Njk4XCIgXSBdLCBbIFwiVmVuZXp1ZWxhXCIsIFwidmVcIiwgXCI1OFwiIF0sIFsgXCJWaWV0bmFtIChWaeG7h3QgTmFtKVwiLCBcInZuXCIsIFwiODRcIiBdLCBbIFwiV2FsbGlzIGFuZCBGdXR1bmEgKFdhbGxpcy1ldC1GdXR1bmEpXCIsIFwid2ZcIiwgXCI2ODFcIiBdLCBbIFwiV2VzdGVybiBTYWhhcmEgKOKAq9in2YTYtdit2LHYp9ihINin2YTYutix2KjZitip4oCs4oCOKVwiLCBcImVoXCIsIFwiMjEyXCIsIDEsIFsgXCI1Mjg4XCIsIFwiNTI4OVwiIF0gXSwgWyBcIlllbWVuICjigKvYp9mE2YrZhdmG4oCs4oCOKVwiLCBcInllXCIsIFwiOTY3XCIgXSwgWyBcIlphbWJpYVwiLCBcInptXCIsIFwiMjYwXCIgXSwgWyBcIlppbWJhYndlXCIsIFwiendcIiwgXCIyNjNcIiBdLCBbIFwiw4VsYW5kIElzbGFuZHNcIiwgXCJheFwiLCBcIjM1OFwiLCAxLCBbIFwiMThcIiBdIF0gXTtcbiAgICAgICAgLy8gbG9vcCBvdmVyIGFsbCBvZiB0aGUgY291bnRyaWVzIGFib3ZlLCByZXN0cnVjdHVyaW5nIHRoZSBkYXRhIHRvIGJlIG9iamVjdHMgd2l0aCBuYW1lZCBrZXlzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsQ291bnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGFsbENvdW50cmllc1tpXTtcbiAgICAgICAgICAgIGFsbENvdW50cmllc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBjWzBdLFxuICAgICAgICAgICAgICAgIGlzbzI6IGNbMV0sXG4gICAgICAgICAgICAgICAgZGlhbENvZGU6IGNbMl0sXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IGNbM10gfHwgMCxcbiAgICAgICAgICAgICAgICBhcmVhQ29kZXM6IGNbNF0gfHwgbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgICAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGxUZWxJbnB1dEdsb2JhbHMgPSB7XG4gICAgICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWludGwtdGVsLWlucHV0LWlkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaW50bFRlbElucHV0R2xvYmFscy5pbnN0YW5jZXNbaWRdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RhbmNlczoge30sXG4gICAgICAgICAgICAvLyB1c2luZyBhIGdsb2JhbCBsaWtlIHRoaXMgYWxsb3dzIHVzIHRvIG1vY2sgaXQgaW4gdGhlIHRlc3RzXG4gICAgICAgICAgICBkb2N1bWVudFJlYWR5OiBmdW5jdGlvbiBkb2N1bWVudFJlYWR5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSB3aW5kb3cuaW50bFRlbElucHV0R2xvYmFscyA9IGludGxUZWxJbnB1dEdsb2JhbHM7XG4gICAgICAgIC8vIHRoZXNlIHZhcnMgcGVyc2lzdCB0aHJvdWdoIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHBsdWdpblxuICAgICAgICB2YXIgaWQgPSAwO1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCB0byBhbGxvdyB0aGUgZHJvcGRvd25cbiAgICAgICAgICAgIGFsbG93RHJvcGRvd246IHRydWUsXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBqdXN0IGEgZGlhbCBjb2RlIGluIHRoZSBpbnB1dDogcmVtb3ZlIGl0IG9uIGJsdXJcbiAgICAgICAgICAgIGF1dG9IaWRlRGlhbENvZGU6IHRydWUsXG4gICAgICAgICAgICAvLyBhZGQgYSBwbGFjZWhvbGRlciBpbiB0aGUgaW5wdXQgd2l0aCBhbiBleGFtcGxlIG51bWJlciBmb3IgdGhlIHNlbGVjdGVkIGNvdW50cnlcbiAgICAgICAgICAgIGF1dG9QbGFjZWhvbGRlcjogXCJwb2xpdGVcIixcbiAgICAgICAgICAgIC8vIG1vZGlmeSB0aGUgcGFyZW50Q2xhc3NcbiAgICAgICAgICAgIGN1c3RvbUNvbnRhaW5lcjogXCJcIixcbiAgICAgICAgICAgIC8vIG1vZGlmeSB0aGUgYXV0byBwbGFjZWhvbGRlclxuICAgICAgICAgICAgY3VzdG9tUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgICAgICAgICAvLyBhcHBlbmQgbWVudSB0byBzcGVjaWZpZWQgZWxlbWVudFxuICAgICAgICAgICAgZHJvcGRvd25Db250YWluZXI6IG51bGwsXG4gICAgICAgICAgICAvLyBkb24ndCBkaXNwbGF5IHRoZXNlIGNvdW50cmllc1xuICAgICAgICAgICAgZXhjbHVkZUNvdW50cmllczogW10sXG4gICAgICAgICAgICAvLyBmb3JtYXQgdGhlIGlucHV0IHZhbHVlIGR1cmluZyBpbml0aWFsaXNhdGlvbiBhbmQgb24gc2V0TnVtYmVyXG4gICAgICAgICAgICBmb3JtYXRPbkRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICAvLyBnZW9JcCBsb29rdXAgZnVuY3Rpb25cbiAgICAgICAgICAgIGdlb0lwTG9va3VwOiBudWxsLFxuICAgICAgICAgICAgLy8gaW5qZWN0IGEgaGlkZGVuIGlucHV0IHdpdGggdGhpcyBuYW1lLCBhbmQgb24gc3VibWl0LCBwb3B1bGF0ZSBpdCB3aXRoIHRoZSByZXN1bHQgb2YgZ2V0TnVtYmVyXG4gICAgICAgICAgICBoaWRkZW5JbnB1dDogXCJcIixcbiAgICAgICAgICAgIC8vIGluaXRpYWwgY291bnRyeVxuICAgICAgICAgICAgaW5pdGlhbENvdW50cnk6IFwiXCIsXG4gICAgICAgICAgICAvLyBsb2NhbGl6ZWQgY291bnRyeSBuYW1lcyBlLmcuIHsgJ2RlJzogJ0RldXRzY2hsYW5kJyB9XG4gICAgICAgICAgICBsb2NhbGl6ZWRDb3VudHJpZXM6IG51bGwsXG4gICAgICAgICAgICAvLyBkb24ndCBpbnNlcnQgaW50ZXJuYXRpb25hbCBkaWFsIGNvZGVzXG4gICAgICAgICAgICBuYXRpb25hbE1vZGU6IHRydWUsXG4gICAgICAgICAgICAvLyBkaXNwbGF5IG9ubHkgdGhlc2UgY291bnRyaWVzXG4gICAgICAgICAgICBvbmx5Q291bnRyaWVzOiBbXSxcbiAgICAgICAgICAgIC8vIG51bWJlciB0eXBlIHRvIHVzZSBmb3IgcGxhY2Vob2xkZXJzXG4gICAgICAgICAgICBwbGFjZWhvbGRlck51bWJlclR5cGU6IFwiTU9CSUxFXCIsXG4gICAgICAgICAgICAvLyB0aGUgY291bnRyaWVzIGF0IHRoZSB0b3Agb2YgdGhlIGxpc3QuIGRlZmF1bHRzIHRvIHVuaXRlZCBzdGF0ZXMgYW5kIHVuaXRlZCBraW5nZG9tXG4gICAgICAgICAgICBwcmVmZXJyZWRDb3VudHJpZXM6IFsgXCJ1c1wiLCBcImdiXCIgXSxcbiAgICAgICAgICAgIC8vIGRpc3BsYXkgdGhlIGNvdW50cnkgZGlhbCBjb2RlIG5leHQgdG8gdGhlIHNlbGVjdGVkIGZsYWcgc28gaXQncyBub3QgcGFydCBvZiB0aGUgdHlwZWQgbnVtYmVyXG4gICAgICAgICAgICBzZXBhcmF0ZURpYWxDb2RlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIHNwZWNpZnkgdGhlIHBhdGggdG8gdGhlIGxpYnBob25lbnVtYmVyIHNjcmlwdCB0byBlbmFibGUgdmFsaWRhdGlvbi9mb3JtYXR0aW5nXG4gICAgICAgICAgICB1dGlsc1NjcmlwdDogXCJcIlxuICAgICAgICB9O1xuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX05vcnRoX0FtZXJpY2FuX051bWJlcmluZ19QbGFuX2FyZWFfY29kZXMjTm9uLWdlb2dyYXBoaWNfYXJlYV9jb2Rlc1xuICAgICAgICB2YXIgcmVnaW9ubGVzc05hbnBOdW1iZXJzID0gWyBcIjgwMFwiLCBcIjgyMlwiLCBcIjgzM1wiLCBcIjg0NFwiLCBcIjg1NVwiLCBcIjg2NlwiLCBcIjg3N1wiLCBcIjg4MFwiLCBcIjg4MVwiLCBcIjg4MlwiLCBcIjg4M1wiLCBcIjg4NFwiLCBcIjg4NVwiLCBcIjg4NlwiLCBcIjg4N1wiLCBcIjg4OFwiLCBcIjg4OVwiIF07XG4gICAgICAgIC8vIHV0aWxpdHkgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGFuIG9iamVjdC4gY2FuJ3QgdXNlIE9iamVjdC5lbnRyaWVzIG9yIG5hdGl2ZSBmb3JFYWNoIGJlY2F1c2VcbiAgICAgICAgLy8gb2YgSUUxMVxuICAgICAgICB2YXIgZm9yRWFjaFByb3AgPSBmdW5jdGlvbiBmb3JFYWNoUHJvcChvYmosIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBydW4gYSBtZXRob2Qgb24gZWFjaCBpbnN0YW5jZSBvZiB0aGUgcGx1Z2luXG4gICAgICAgIHZhciBmb3JFYWNoSW5zdGFuY2UgPSBmdW5jdGlvbiBmb3JFYWNoSW5zdGFuY2UobWV0aG9kKSB7XG4gICAgICAgICAgICBmb3JFYWNoUHJvcCh3aW5kb3cuaW50bFRlbElucHV0R2xvYmFscy5pbnN0YW5jZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5pbnRsVGVsSW5wdXRHbG9iYWxzLmluc3RhbmNlc1trZXldW21ldGhvZF0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyB0aGlzIGlzIG91ciBwbHVnaW4gY2xhc3MgdGhhdCB3ZSB3aWxsIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgdmFyIEl0aSA9IC8qI19fUFVSRV9fKi9cbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBJdGkoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJdGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBpZCsrO1xuICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHNwZWNpZmllZCBvcHRpb25zIC8gZGVmYXVsdHNcbiAgICAgICAgICAgICAgICAvLyBhbHRlcm5hdGl2ZSB0byBPYmplY3QuYXNzaWduLCB3aGljaCBpc24ndCBzdXBwb3J0ZWQgYnkgSUUxMVxuICAgICAgICAgICAgICAgIHZhciBjdXN0b21PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoUHJvcChkZWZhdWx0cywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zW2tleV0gPSBjdXN0b21PcHRpb25zLmhhc093blByb3BlcnR5KGtleSkgPyBjdXN0b21PcHRpb25zW2tleV0gOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhZEluaXRpYWxQbGFjZWhvbGRlciA9IEJvb2xlYW4oaW5wdXQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2NyZWF0ZUNsYXNzKEl0aSwgWyB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9pbml0XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaW4gbmF0aW9uYWxNb2RlLCBkaXNhYmxlIG9wdGlvbnMgcmVsYXRpbmcgdG8gZGlhbCBjb2Rlc1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5hdGlvbmFsTW9kZSkgdGhpcy5vcHRpb25zLmF1dG9IaWRlRGlhbENvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2VwYXJhdGVEaWFsQ29kZSB0aGVuIGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBBKSBpbnNlcnQgZGlhbCBjb2RlIGludG8gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgLy8gKGF1dG9IaWRlRGlhbENvZGUpLCBhbmQgQikgZGlzcGxheSBuYXRpb25hbCBudW1iZXJzIChiZWNhdXNlIHdlJ3JlIGRpc3BsYXlpbmcgdGhlIGNvdW50cnlcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlhbCBjb2RlIG5leHQgdG8gdGhlbSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXBhcmF0ZURpYWxDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b0hpZGVEaWFsQ29kZSA9IHRoaXMub3B0aW9ucy5uYXRpb25hbE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QganVzdCB0ZXN0IHNjcmVlbiBzaXplIGFzIHNvbWUgc21hcnRwaG9uZXMvd2Vic2l0ZSBtZXRhIHRhZ3Mgd2lsbCByZXBvcnQgZGVza3RvcFxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHV0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBmb3Igc29tZSByZWFzb24gamFzbWluZSBicmVha3MgaWYgeW91IHB1dCB0aGlzIGluIHRoZSBtYWluIFBsdWdpbiBmdW5jdGlvbiB3aXRoIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXN0IG9mIHRoZXNlIGRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB0byB0YXJnZXQgQW5kcm9pZCBNb2JpbGVzIChhbmQgbm90IFRhYmxldHMpLCB3ZSBtdXN0IGZpbmQgJ0FuZHJvaWQnIGFuZCAnTW9iaWxlJ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzTW9iaWxlID0gL0FuZHJvaWQuK01vYmlsZXx3ZWJPU3xpUGhvbmV8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciB0aGUgbW9iaWxlIGRyb3Bkb3duIGNzc1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiaXRpLW1vYmlsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIG1vYmlsZSwgd2Ugd2FudCBhIGZ1bGwgc2NyZWVuIGRyb3Bkb3duLCBzbyB3ZSBtdXN0IGFwcGVuZCBpdCB0byB0aGUgYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJvcGRvd25Db250YWluZXIpIHRoaXMub3B0aW9ucy5kcm9wZG93bkNvbnRhaW5lciA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvbWlzZXMgZ2V0IHJlc29sdmVkIHdoZW4gdGhlaXIgaW5kaXZpZHVhbCByZXF1ZXN0cyBjb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdheSB0aGUgZGV2IGNhbiBkbyBzb21ldGhpbmcgbGlrZSBpdGkucHJvbWlzZS50aGVuKC4uLikgdG8ga25vdyB3aGVuIGFsbCByZXF1ZXN0cyBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXV0b0NvdW50cnlQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLnJlc29sdmVBdXRvQ291bnRyeVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5yZWplY3RBdXRvQ291bnRyeVByb21pc2UgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1dGlsc1NjcmlwdFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIucmVzb2x2ZVV0aWxzU2NyaXB0UHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLnJlamVjdFV0aWxzU2NyaXB0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9taXNlID0gUHJvbWlzZS5hbGwoWyBhdXRvQ291bnRyeVByb21pc2UsIHV0aWxzU2NyaXB0UHJvbWlzZSBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZXJyb3JzIHdoZW4gUHJvbWlzZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVBdXRvQ291bnRyeVByb21pc2UgPSB0aGlzLnJlamVjdEF1dG9Db3VudHJ5UHJvbWlzZSA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVVdGlsc1NjcmlwdFByb21pc2UgPSB0aGlzLnJlamVjdFV0aWxzU2NyaXB0UHJvbWlzZSA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdmFyaW91cyBzaXR1YXRpb25zIHRoZXJlIGNvdWxkIGJlIG5vIGNvdW50cnkgc2VsZWN0ZWQgaW5pdGlhbGx5LCBidXQgd2UgbmVlZCB0byBiZSBhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFzc3VtZSB0aGlzIHZhcmlhYmxlIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyBhbGwgdGhlIGRhdGE6IG9ubHlDb3VudHJpZXMsIGV4Y2x1ZGVDb3VudHJpZXMsIHByZWZlcnJlZENvdW50cmllcyBldGNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0NvdW50cnlEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIHRoZSBtYXJrdXBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGVNYXJrdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBpbnB1dCB2YWx1ZSBhbmQgdGhlIHNlbGVjdGVkIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGFsbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXJzOiBhdXRvSGlkZURpYWxDb2RlLCBpbnB1dCBrZXlkb3duLCBzZWxlY3RlZEZsYWcgY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1dGlscyBzY3JpcHQsIGFuZCBhdXRvIGNvdW50cnlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdFJlcXVlc3RzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfcHJvY2Vzc0NvdW50cnlEYXRhXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzQ291bnRyeURhdGEoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2Nlc3Mgb25seUNvdW50cmllcyBvciBleGNsdWRlQ291bnRyaWVzIGFycmF5IGlmIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0FsbENvdW50cmllcygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBjb3VudHJ5Q29kZXMgbWFwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NDb3VudHJ5Q29kZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgcHJlZmVycmVkQ291bnRyaWVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NQcmVmZXJyZWRDb3VudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIGNvdW50cmllcyBhY2NvcmRpbmcgdG8gbG9jYWxpemVkQ291bnRyaWVzIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2FsaXplZENvdW50cmllcykgdGhpcy5fdHJhbnNsYXRlQ291bnRyaWVzQnlMb2NhbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc29ydCBjb3VudHJpZXMgYnkgbmFtZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9ubHlDb3VudHJpZXMubGVuZ3RoIHx8IHRoaXMub3B0aW9ucy5sb2NhbGl6ZWRDb3VudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRyaWVzLnNvcnQodGhpcy5fY291bnRyeU5hbWVTb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2FkZENvdW50cnlDb2RlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDb3VudHJ5Q29kZShpc28yLCBjb3VudHJ5Q29kZSwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50cnlDb2RlLmxlbmd0aCA+IHRoaXMuY291bnRyeUNvZGVNYXhMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRyeUNvZGVNYXhMZW4gPSBjb3VudHJ5Q29kZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvdW50cnlDb2Rlcy5oYXNPd25Qcm9wZXJ0eShjb3VudHJ5Q29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRyeUNvZGVzW2NvdW50cnlDb2RlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGJhaWwgaWYgd2UgYWxyZWFkeSBoYXZlIHRoaXMgY291bnRyeSBmb3IgdGhpcyBjb3VudHJ5Q29kZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY291bnRyeUNvZGVzW2NvdW50cnlDb2RlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRyeUNvZGVzW2NvdW50cnlDb2RlXVtpXSA9PT0gaXNvMikgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB1bmRlZmluZWQgYXMgMCBpcyBmYWxzeVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwcmlvcml0eSAhPT0gdW5kZWZpbmVkID8gcHJpb3JpdHkgOiB0aGlzLmNvdW50cnlDb2Rlc1tjb3VudHJ5Q29kZV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50cnlDb2Rlc1tjb3VudHJ5Q29kZV1baW5kZXhdID0gaXNvMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9wcm9jZXNzQWxsQ291bnRyaWVzXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzQWxsQ291bnRyaWVzKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9ubHlDb3VudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXJDYXNlT25seUNvdW50cmllcyA9IHRoaXMub3B0aW9ucy5vbmx5Q291bnRyaWVzLm1hcChmdW5jdGlvbihjb3VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50cnkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHJpZXMgPSBhbGxDb3VudHJpZXMuZmlsdGVyKGZ1bmN0aW9uKGNvdW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXJDYXNlT25seUNvdW50cmllcy5pbmRleE9mKGNvdW50cnkuaXNvMikgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5leGNsdWRlQ291bnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VyQ2FzZUV4Y2x1ZGVDb3VudHJpZXMgPSB0aGlzLm9wdGlvbnMuZXhjbHVkZUNvdW50cmllcy5tYXAoZnVuY3Rpb24oY291bnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudHJ5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRyaWVzID0gYWxsQ291bnRyaWVzLmZpbHRlcihmdW5jdGlvbihjb3VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyQ2FzZUV4Y2x1ZGVDb3VudHJpZXMuaW5kZXhPZihjb3VudHJ5LmlzbzIpID09PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHJpZXMgPSBhbGxDb3VudHJpZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl90cmFuc2xhdGVDb3VudHJpZXNCeUxvY2FsZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJhbnNsYXRlQ291bnRyaWVzQnlMb2NhbGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb3VudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc28gPSB0aGlzLmNvdW50cmllc1tpXS5pc28yLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxvY2FsaXplZENvdW50cmllcy5oYXNPd25Qcm9wZXJ0eShpc28pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHJpZXNbaV0ubmFtZSA9IHRoaXMub3B0aW9ucy5sb2NhbGl6ZWRDb3VudHJpZXNbaXNvXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2NvdW50cnlOYW1lU29ydFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY291bnRyeU5hbWVTb3J0KGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfcHJvY2Vzc0NvdW50cnlDb2Rlc1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc0NvdW50cnlDb2RlcygpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHJ5Q29kZU1heExlbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlcmUgd2Ugc3RvcmUganVzdCBkaWFsIGNvZGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlhbENvZGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlcmUgd2Ugc3RvcmUgXCJjb3VudHJ5IGNvZGVzXCIgKGJvdGggZGlhbCBjb2RlcyBhbmQgdGhlaXIgYXJlYSBjb2RlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHJ5Q29kZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3Q6IGFkZCBkaWFsIGNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb3VudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb3VudHJpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGlhbENvZGVzW2MuZGlhbENvZGVdKSB0aGlzLmRpYWxDb2Rlc1tjLmRpYWxDb2RlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDb3VudHJ5Q29kZShjLmlzbzIsIGMuZGlhbENvZGUsIGMucHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQ6IGFkZCBhcmVhIGNvZGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzZWNvbmQgbG9vcCBvdmVyIGNvdW50cmllcywgdG8gbWFrZSBzdXJlIHdlIGhhdmUgYWxsIG9mIHRoZSBcInJvb3RcIiBjb3VudHJpZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBpbiB0aGUgbWFwLCBzbyB0aGF0IHdlIGNhbiBhY2Nlc3MgdGhlbSwgYXMgZWFjaCB0aW1lIHdlIGFkZCBhbiBhcmVhIGNvZGUgc3Vic3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBtYXAsIHdlIGFsc28gbmVlZCB0byBpbmNsdWRlIHRoZSBcInJvb3RcIiBjb3VudHJ5J3MgY29kZSwgYXMgdGhhdCBhbHNvIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuY291bnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gdGhpcy5jb3VudHJpZXNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlYSBjb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jLmFyZWFDb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290Q291bnRyeUNvZGUgPSB0aGlzLmNvdW50cnlDb2Rlc1tfYy5kaWFsQ29kZV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggYXJlYSBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfYy5hcmVhQ29kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZWFDb2RlID0gX2MuYXJlYUNvZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBkaWdpdCBpbiB0aGUgYXJlYSBjb2RlIHRvIGFkZCBhbGwgcGFydGlhbCBtYXRjaGVzIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBhcmVhQ29kZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxEaWFsQ29kZSA9IF9jLmRpYWxDb2RlICsgYXJlYUNvZGUuc3Vic3RyKDAsIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgd2l0aCB0aGUgcm9vdCBjb3VudHJ5LCBhcyB0aGF0IGFsc28gbWF0Y2hlcyB0aGlzIGRpYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ291bnRyeUNvZGUocm9vdENvdW50cnlDb2RlLCBwYXJ0aWFsRGlhbENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ291bnRyeUNvZGUoX2MuaXNvMiwgcGFydGlhbERpYWxDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGZ1bGwgYXJlYSBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENvdW50cnlDb2RlKF9jLmlzbzIsIF9jLmRpYWxDb2RlICsgYXJlYUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX3Byb2Nlc3NQcmVmZXJyZWRDb3VudHJpZXNcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NQcmVmZXJyZWRDb3VudHJpZXMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlZmVycmVkQ291bnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLnByZWZlcnJlZENvdW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50cnlDb2RlID0gdGhpcy5vcHRpb25zLnByZWZlcnJlZENvdW50cmllc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50cnlEYXRhID0gdGhpcy5fZ2V0Q291bnRyeURhdGEoY291bnRyeUNvZGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudHJ5RGF0YSkgdGhpcy5wcmVmZXJyZWRDb3VudHJpZXMucHVzaChjb3VudHJ5RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9jcmVhdGVFbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWwobmFtZSwgYXR0cnMsIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnMpIGZvckVhY2hQcm9wKGF0dHJzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2dlbmVyYXRlTWFya3VwXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZW5lcmF0ZU1hcmt1cCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYXV0b2NvbXBsZXRlIGRvZXMgbm90IGV4aXN0IG9uIHRoZSBlbGVtZW50IGFuZCBpdHMgZm9ybSwgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGF1dG9jb21wbGV0ZSBhcyB0aGVyZSdzIG5vIHNhZmUsIGNyb3NzLWJyb3dzZXIgZXZlbnQgd2UgY2FuIHJlYWN0IHRvLCBzbyBpdCBjYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gZWFzaWx5IHB1dCB0aGUgcGx1Z2luIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSBlLmcuIHRoZSB3cm9uZyBmbGFnIHNlbGVjdGVkIGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYXV0b2NvbXBsZXRlZCBudW1iZXIsIHdoaWNoIG9uIHN1Ym1pdCBjb3VsZCBtZWFuIHdyb25nIG51bWJlciBpcyBzYXZlZCAoZXNwIGluIG5hdGlvbmFsTW9kZSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRlbElucHV0Lmhhc0F0dHJpYnV0ZShcImF1dG9jb21wbGV0ZVwiKSAmJiAhKHRoaXMudGVsSW5wdXQuZm9ybSAmJiB0aGlzLnRlbElucHV0LmZvcm0uaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZWxJbnB1dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGFpbmVycyAobW9zdGx5IGZvciBwb3NpdGlvbmluZylcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudENsYXNzID0gXCJpdGlcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0Ryb3Bkb3duKSBwYXJlbnRDbGFzcyArPSBcIiBpdGktLWFsbG93LWRyb3Bkb3duXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VwYXJhdGVEaWFsQ29kZSkgcGFyZW50Q2xhc3MgKz0gXCIgaXRpLS1zZXBhcmF0ZS1kaWFsLWNvZGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXN0b21Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENsYXNzICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q2xhc3MgKz0gdGhpcy5vcHRpb25zLmN1c3RvbUNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMuX2NyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogcGFyZW50Q2xhc3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlciwgdGhpcy50ZWxJbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhZ3NDb250YWluZXIgPSB0aGlzLl9jcmVhdGVFbChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwiaXRpX19mbGFnLWNvbnRhaW5lclwiXG4gICAgICAgICAgICAgICAgICAgIH0sIHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMudGVsSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RlZCBmbGFnIChkaXNwbGF5ZWQgdG8gbGVmdCBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZsYWcgPSB0aGlzLl9jcmVhdGVFbChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwiaXRpX19zZWxlY3RlZC1mbGFnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcImNvbWJvYm94XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtY29udHJvbHNcIjogXCJpdGktXCIuY29uY2F0KHRoaXMuaWQsIFwiX19jb3VudHJ5LWxpc3Rib3hcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtb3duc1wiOiBcIml0aS1cIi5jb25jYXQodGhpcy5pZCwgXCJfX2NvdW50cnktbGlzdGJveFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBcImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5mbGFnc0NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGbGFnSW5uZXIgPSB0aGlzLl9jcmVhdGVFbChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwiaXRpX19mbGFnXCJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zZWxlY3RlZEZsYWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlcGFyYXRlRGlhbENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREaWFsQ29kZSA9IHRoaXMuX2NyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwiaXRpX19zZWxlY3RlZC1kaWFsLWNvZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5zZWxlY3RlZEZsYWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dEcm9wZG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBlbGVtZW50IGZvY3VzYWJsZSBhbmQgdGFiIG5hdmlnYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZsYWcuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bkFycm93ID0gdGhpcy5fY3JlYXRlRWwoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogXCJpdGlfX2Fycm93XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuc2VsZWN0ZWRGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50cnkgZHJvcGRvd246IHByZWZlcnJlZCBjb3VudHJpZXMsIHRoZW4gZGl2aWRlciwgdGhlbiBhbGwgY291bnRyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50cnlMaXN0ID0gdGhpcy5fY3JlYXRlRWwoXCJ1bFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBcIml0aV9fY291bnRyeS1saXN0IGl0aV9faGlkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIml0aS1cIi5jb25jYXQodGhpcy5pZCwgXCJfX2NvdW50cnktbGlzdGJveFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogXCJMaXN0IG9mIGNvdW50cmllc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZWZlcnJlZENvdW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRMaXN0SXRlbXModGhpcy5wcmVmZXJyZWRDb3VudHJpZXMsIFwiaXRpX19wcmVmZXJyZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlRWwoXCJsaVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogXCJpdGlfX2RpdmlkZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5jb3VudHJ5TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRMaXN0SXRlbXModGhpcy5jb3VudHJpZXMsIFwiaXRpX19zdGFuZGFyZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBkcm9wZG93bkNvbnRhaW5lciBtYXJrdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcGRvd25Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duID0gdGhpcy5fY3JlYXRlRWwoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IFwiaXRpIGl0aS0tY29udGFpbmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFwcGVuZENoaWxkKHRoaXMuY291bnRyeUxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsYWdzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY291bnRyeUxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZGVuSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWRkZW5JbnB1dE5hbWUgPSB0aGlzLm9wdGlvbnMuaGlkZGVuSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGVsSW5wdXQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuYW1lLmxhc3RJbmRleE9mKFwiW1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpbnB1dCBuYW1lIGNvbnRhaW5zIHNxdWFyZSBicmFja2V0cywgdGhlbiBnaXZlIHRoZSBoaWRkZW4gaW5wdXQgdGhlIHNhbWUgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBsYXN0IHNldCBvZiBicmFja2V0cyB3aXRoIHRoZSBnaXZlbiBoaWRkZW5JbnB1dCBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSBoaWRkZW5JbnB1dE5hbWUgPSBcIlwiLmNvbmNhdChuYW1lLnN1YnN0cigwLCBpKSwgXCJbXCIpLmNvbmNhdChoaWRkZW5JbnB1dE5hbWUsIFwiXVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuSW5wdXQgPSB0aGlzLl9jcmVhdGVFbChcImlucHV0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGhpZGRlbklucHV0TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuaGlkZGVuSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfYXBwZW5kTGlzdEl0ZW1zXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBlbmRMaXN0SXRlbXMoY291bnRyaWVzLCBjbGFzc05hbWUsIHByZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjcmVhdGUgc28gbWFueSBET00gZWxlbWVudHMsIGl0IGlzIGZhc3RlciB0byBidWlsZCBhIHRlbXAgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVuIGFkZCBldmVyeXRoaW5nIHRvIHRoZSBET00gaW4gb25lIGdvIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIGNvdW50cnlcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gY291bnRyaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkU3VmZml4ID0gcHJlZmVycmVkID8gXCItcHJlZmVycmVkXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3BlbiB0aGUgbGlzdCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgKz0gXCI8bGkgY2xhc3M9J2l0aV9fY291bnRyeSBcIi5jb25jYXQoY2xhc3NOYW1lLCBcIicgdGFiSW5kZXg9Jy0xJyBpZD0naXRpLVwiKS5jb25jYXQodGhpcy5pZCwgXCJfX2l0ZW0tXCIpLmNvbmNhdChjLmlzbzIpLmNvbmNhdChpZFN1ZmZpeCwgXCInIHJvbGU9J29wdGlvbicgZGF0YS1kaWFsLWNvZGU9J1wiKS5jb25jYXQoYy5kaWFsQ29kZSwgXCInIGRhdGEtY291bnRyeS1jb2RlPSdcIikuY29uY2F0KGMuaXNvMiwgXCInIGFyaWEtc2VsZWN0ZWQ9J2ZhbHNlJz5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGZsYWdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCArPSBcIjxkaXYgY2xhc3M9J2l0aV9fZmxhZy1ib3gnPjxkaXYgY2xhc3M9J2l0aV9fZmxhZyBpdGlfX1wiLmNvbmNhdChjLmlzbzIsIFwiJz48L2Rpdj48L2Rpdj5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIGNvdW50cnkgbmFtZSBhbmQgZGlhbCBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgKz0gXCI8c3BhbiBjbGFzcz0naXRpX19jb3VudHJ5LW5hbWUnPlwiLmNvbmNhdChjLm5hbWUsIFwiPC9zcGFuPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCArPSBcIjxzcGFuIGNsYXNzPSdpdGlfX2RpYWwtY29kZSc+K1wiLmNvbmNhdChjLmRpYWxDb2RlLCBcIjwvc3Bhbj5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSB0aGUgbGlzdCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgKz0gXCI8L2xpPlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRyeUxpc3QuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIHRtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfc2V0SW5pdGlhbFN0YXRlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeCBmaXJlZm94IGJ1Zzogd2hlbiBmaXJzdCBsb2FkIHBhZ2UgKHdpdGggaW5wdXQgd2l0aCB2YWx1ZSBzZXQgdG8gbnVtYmVyIHdpdGggaW50bCBkaWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUpIGFuZCBpbml0aWFsaXNpbmcgcGx1Z2luIHJlbW92ZXMgdGhlIGRpYWwgY29kZSBmcm9tIHRoZSBpbnB1dCwgdGhlbiByZWZyZXNoIHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSB0cnkgdG8gaW5pdCBwbHVnaW4gYWdhaW4gYnV0IHRoaXMgdGltZSBvbiBudW1iZXIgd2l0aG91dCBkaWFsIGNvZGUgc28gZ2V0IGdyZXkgZmxhZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSB0aGlzLnRlbElucHV0LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZSA9IHRoaXMudGVsSW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1c2VBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVWYWx1ZSAmJiBhdHRyaWJ1dGVWYWx1ZS5jaGFyQXQoMCkgPT09IFwiK1wiICYmICghaW5wdXRWYWx1ZSB8fCBpbnB1dFZhbHVlLmNoYXJBdCgwKSAhPT0gXCIrXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdXNlQXR0cmlidXRlID8gYXR0cmlidXRlVmFsdWUgOiBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlhbENvZGUgPSB0aGlzLl9nZXREaWFsQ29kZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSZWdpb25sZXNzTmFucCA9IHRoaXMuX2lzUmVnaW9ubGVzc05hbnAodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIGluaXRpYWxDb3VudHJ5ID0gX3RoaXMkb3B0aW9ucy5pbml0aWFsQ291bnRyeSwgbmF0aW9uYWxNb2RlID0gX3RoaXMkb3B0aW9ucy5uYXRpb25hbE1vZGUsIGF1dG9IaWRlRGlhbENvZGUgPSBfdGhpcyRvcHRpb25zLmF1dG9IaWRlRGlhbENvZGUsIHNlcGFyYXRlRGlhbENvZGUgPSBfdGhpcyRvcHRpb25zLnNlcGFyYXRlRGlhbENvZGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGRpYWwgY29kZSwgYW5kIGl0J3Mgbm90IGEgcmVnaW9ubGVzc05hbnAsIHdlIGNhbiBnbyBhaGVhZCBhbmQgc2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBmbGFnLCBlbHNlIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBjb3VudHJ5XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWFsQ29kZSAmJiAhaXNSZWdpb25sZXNzTmFucCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRmxhZ0Zyb21OdW1iZXIodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbml0aWFsQ291bnRyeSAhPT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBpZiB3ZSBzaG91bGQgc2VsZWN0IGEgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxDb3VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RmxhZyhpbml0aWFsQ291bnRyeS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpYWxDb2RlICYmIGlzUmVnaW9ubGVzc05hbnApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGludGwgZGlhbCBjb2RlLCBpcyByZWdpb25sZXNzIG5hbnAsIGFuZCBubyBpbml0aWFsQ291bnRyeSwgc28gZGVmYXVsdCB0byBVU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRGbGFnKFwidXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZGlhbCBjb2RlIGFuZCBubyBpbml0aWFsQ291bnRyeSwgc28gZGVmYXVsdCB0byBmaXJzdCBpbiBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdENvdW50cnkgPSB0aGlzLnByZWZlcnJlZENvdW50cmllcy5sZW5ndGggPyB0aGlzLnByZWZlcnJlZENvdW50cmllc1swXS5pc28yIDogdGhpcy5jb3VudHJpZXNbMF0uaXNvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEZsYWcodGhpcy5kZWZhdWx0Q291bnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBlbXB0eSBhbmQgbm8gbmF0aW9uYWxNb2RlIGFuZCBubyBhdXRvSGlkZURpYWxDb2RlIHRoZW4gaW5zZXJ0IHRoZSBkZWZhdWx0IGRpYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWwgJiYgIW5hdGlvbmFsTW9kZSAmJiAhYXV0b0hpZGVEaWFsQ29kZSAmJiAhc2VwYXJhdGVEaWFsQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQudmFsdWUgPSBcIitcIi5jb25jYXQodGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmRpYWxDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBpZiBpbml0aWFsQ291bnRyeSBpcyBzZXQgdG8gYXV0bywgdGhhdCB3aWxsIGJlIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3JtYXQgLSBub3RlIHRoaXMgd29udCBiZSBydW4gYWZ0ZXIgX3VwZGF0ZURpYWxDb2RlIGFzIHRoYXQncyBvbmx5IGNhbGxlZCBpZiBubyB2YWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkgdGhpcy5fdXBkYXRlVmFsRnJvbU51bWJlcih2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2luaXRMaXN0ZW5lcnNcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRLZXlMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGlkZURpYWxDb2RlKSB0aGlzLl9pbml0Qmx1ckxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RHJvcGRvd24pIHRoaXMuX2luaXREcm9wZG93bkxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWRkZW5JbnB1dCkgdGhpcy5faW5pdEhpZGRlbklucHV0TGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9pbml0SGlkZGVuSW5wdXRMaXN0ZW5lclwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdEhpZGRlbklucHV0TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVIaWRkZW5JbnB1dFN1Ym1pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLmhpZGRlbklucHV0LnZhbHVlID0gX3RoaXMzLmdldE51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZWxJbnB1dC5mb3JtKSB0aGlzLnRlbElucHV0LmZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCB0aGlzLl9oYW5kbGVIaWRkZW5JbnB1dFN1Ym1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfZ2V0Q2xvc2VzdExhYmVsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDbG9zZXN0TGFiZWwoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMudGVsSW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbCAmJiBlbC50YWdOYW1lICE9PSBcIkxBQkVMXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfaW5pdERyb3Bkb3duTGlzdGVuZXJzXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0RHJvcGRvd25MaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvLyBoYWNrIGZvciBpbnB1dCBuZXN0ZWQgaW5zaWRlIGxhYmVsICh3aGljaCBpcyB2YWxpZCBtYXJrdXApOiBjbGlja2luZyB0aGUgc2VsZWN0ZWQtZmxhZyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBvcGVuIHRoZSBkcm9wZG93biB3b3VsZCB0aGVuIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciBhIDJuZCBjbGljayBvbiB0aGUgaW5wdXQgd2hpY2ggd291bGRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlTGFiZWxDbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkcm9wZG93biBpcyBjbG9zZWQsIHRoZW4gZm9jdXMgdGhlIGlucHV0LCBlbHNlIGlnbm9yZSB0aGUgY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczQuY291bnRyeUxpc3QuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXRpX19oaWRlXCIpKSBfdGhpczQudGVsSW5wdXQuZm9jdXMoKTsgZWxzZSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX2dldENsb3Nlc3RMYWJlbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwpIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVMYWJlbENsaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9nZ2xlIGNvdW50cnkgZHJvcGRvd24gb24gY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2xpY2tTZWxlY3RlZEZsYWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgaW50ZXJjZXB0IHRoaXMgZXZlbnQgaWYgd2UncmUgb3BlbmluZyB0aGUgZHJvcGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgbGV0IGl0IGJ1YmJsZSB1cCB0byB0aGUgdG9wIChcImNsaWNrLW9mZi10by1jbG9zZVwiIGxpc3RlbmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IGp1c3Qgc3RvcFByb3BhZ2F0aW9uIGFzIGl0IG1heSBiZSBuZWVkZWQgdG8gY2xvc2UgYW5vdGhlciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzNC5jb3VudHJ5TGlzdC5jbGFzc0xpc3QuY29udGFpbnMoXCJpdGlfX2hpZGVcIikgJiYgIV90aGlzNC50ZWxJbnB1dC5kaXNhYmxlZCAmJiAhX3RoaXM0LnRlbElucHV0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM0Ll9zaG93RHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZsYWcuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZUNsaWNrU2VsZWN0ZWRGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3BlbiBkcm9wZG93biBsaXN0IGlmIGN1cnJlbnRseSBmb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZsYWdzQ29udGFpbmVyS2V5ZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0Ryb3Bkb3duSGlkZGVuID0gX3RoaXM0LmNvdW50cnlMaXN0LmNsYXNzTGlzdC5jb250YWlucyhcIml0aV9faGlkZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Ryb3Bkb3duSGlkZGVuICYmIFsgXCJBcnJvd1VwXCIsIFwiVXBcIiwgXCJBcnJvd0Rvd25cIiwgXCJEb3duXCIsIFwiIFwiLCBcIkVudGVyXCIgXS5pbmRleE9mKGUua2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGZvcm0gZnJvbSBiZWluZyBzdWJtaXR0ZWQgaWYgXCJFTlRFUlwiIHdhcyBwcmVzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZXZlbnQgZnJvbSBiZWluZyBoYW5kbGVkIGFnYWluIGJ5IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczQuX3Nob3dEcm9wZG93bigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgbmF2aWdhdGlvbiBmcm9tIGRyb3Bkb3duIHRvIGlucHV0IG9uIFRBQlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIlRhYlwiKSBfdGhpczQuX2Nsb3NlRHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbGFnc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVGbGFnc0NvbnRhaW5lcktleWRvd24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2luaXRSZXF1ZXN0c1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFJlcXVlc3RzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgaGFzIHNwZWNpZmllZCB0aGUgcGF0aCB0byB0aGUgdXRpbHMgc2NyaXB0LCBmZXRjaCBpdCBvbiB3aW5kb3cubG9hZCwgZWxzZSByZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXRpbHNTY3JpcHQgJiYgIXdpbmRvdy5pbnRsVGVsSW5wdXRVdGlscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBsdWdpbiBpcyBiZWluZyBpbml0aWFsaXNlZCBhZnRlciB0aGUgd2luZG93LmxvYWQgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBmaXJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5pbnRsVGVsSW5wdXRHbG9iYWxzLmRvY3VtZW50UmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5pbnRsVGVsSW5wdXRHbG9iYWxzLmxvYWRVdGlscyh0aGlzLm9wdGlvbnMudXRpbHNTY3JpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IHVudGlsIHRoZSBsb2FkIGV2ZW50IHNvIHdlIGRvbid0IGJsb2NrIGFueSBvdGhlciByZXF1ZXN0cyBlLmcuIHRoZSBmbGFncyBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmludGxUZWxJbnB1dEdsb2JhbHMubG9hZFV0aWxzKF90aGlzNS5vcHRpb25zLnV0aWxzU2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMucmVzb2x2ZVV0aWxzU2NyaXB0UHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmluaXRpYWxDb3VudHJ5ID09PSBcImF1dG9cIikgdGhpcy5fbG9hZEF1dG9Db3VudHJ5KCk7IGVsc2UgdGhpcy5yZXNvbHZlQXV0b0NvdW50cnlQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfbG9hZEF1dG9Db3VudHJ5XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkQXV0b0NvdW50cnkoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDMgb3B0aW9uczpcbiAgICAgICAgICAgICAgICAgICAgLy8gMSkgYWxyZWFkeSBsb2FkZWQgKHdlJ3JlIGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIC8vIDIpIG5vdCBhbHJlYWR5IHN0YXJ0ZWQgbG9hZGluZyAoc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIC8vIDMpIGFscmVhZHkgc3RhcnRlZCBsb2FkaW5nIChkbyBub3RoaW5nIC0ganVzdCB3YWl0IGZvciBsb2FkaW5nIGNhbGxiYWNrIHRvIGZpcmUpXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaW50bFRlbElucHV0R2xvYmFscy5hdXRvQ291bnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRvQ291bnRyeSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF3aW5kb3cuaW50bFRlbElucHV0R2xvYmFscy5zdGFydGVkTG9hZGluZ0F1dG9Db3VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBkbyB0aGlzIHR3aWNlIVxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmludGxUZWxJbnB1dEdsb2JhbHMuc3RhcnRlZExvYWRpbmdBdXRvQ291bnRyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5nZW9JcExvb2t1cCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmdlb0lwTG9va3VwKGZ1bmN0aW9uKGNvdW50cnlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5pbnRsVGVsSW5wdXRHbG9iYWxzLmF1dG9Db3VudHJ5ID0gY291bnRyeUNvZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVsbCBhbGwgaW5zdGFuY2VzIHRoZSBhdXRvIGNvdW50cnkgaXMgcmVhZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBzaG91bGQganVzdCBiZSB0aGUgY3VycmVudCBpbnN0YW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVVBEQVRFOiB1c2Ugc2V0VGltZW91dCBpbiBjYXNlIHRoZWlyIGdlb0lwTG9va3VwIGZ1bmN0aW9uIGNhbGxzIHRoaXMgY2FsbGJhY2sgc3RyYWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXdheSAoZS5nLiBpZiB0aGV5IGhhdmUgYWxyZWFkeSBkb25lIHRoZSBnZW8gaXAgbG9va3VwIHNvbWV3aGVyZSBlbHNlKS4gVXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0VGltZW91dCBtZWFucyB0aGF0IHRoZSBjdXJyZW50IHRocmVhZCBvZiBleGVjdXRpb24gd2lsbCBmaW5pc2ggYmVmb3JlIGV4ZWN1dGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLCB3aGljaCBhbGxvd3MgdGhlIHBsdWdpbiB0byBmaW5pc2ggaW5pdGlhbGlzaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvckVhY2hJbnN0YW5jZShcImhhbmRsZUF1dG9Db3VudHJ5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvckVhY2hJbnN0YW5jZShcInJlamVjdEF1dG9Db3VudHJ5UHJvbWlzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2luaXRLZXlMaXN0ZW5lcnNcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRLZXlMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZmxhZyBvbiBrZXl1cFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVLZXl1cEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXM2Ll91cGRhdGVGbGFnRnJvbU51bWJlcihfdGhpczYudGVsSW5wdXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM2Ll90cmlnZ2VyQ291bnRyeUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbElucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9oYW5kbGVLZXl1cEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZsYWcgb24gY3V0L3Bhc3RlIGV2ZW50cyAobm93IHN1cHBvcnRlZCBpbiBhbGwgbWFqb3IgYnJvd3NlcnMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUNsaXBib2FyZEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYWNrIGJlY2F1c2UgXCJwYXN0ZVwiIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSBpbnB1dCBpcyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KF90aGlzNi5faGFuZGxlS2V5dXBFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCB0aGlzLl9oYW5kbGVDbGlwYm9hcmRFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuX2hhbmRsZUNsaXBib2FyZEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9jYXBcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhcChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IHRoaXMudGVsSW5wdXQuZ2V0QXR0cmlidXRlKFwibWF4bGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF4ICYmIG51bWJlci5sZW5ndGggPiBtYXggPyBudW1iZXIuc3Vic3RyKDAsIG1heCkgOiBudW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfaW5pdEJsdXJMaXN0ZW5lcnNcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRCbHVyTGlzdGVuZXJzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gYmx1ciBvciBmb3JtIHN1Ym1pdDogaWYganVzdCBhIGRpYWwgY29kZSB0aGVuIHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVTdWJtaXRPckJsdXJFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM3Ll9yZW1vdmVFbXB0eURpYWxDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlbElucHV0LmZvcm0pIHRoaXMudGVsSW5wdXQuZm9ybS5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMuX2hhbmRsZVN1Ym1pdE9yQmx1ckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZWxJbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9oYW5kbGVTdWJtaXRPckJsdXJFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfcmVtb3ZlRW1wdHlEaWFsQ29kZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRW1wdHlEaWFsQ29kZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVsSW5wdXQudmFsdWUuY2hhckF0KDApID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bWVyaWMgPSB0aGlzLl9nZXROdW1lcmljKHRoaXMudGVsSW5wdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYganVzdCBhIHBsdXMsIG9yIGlmIGp1c3QgYSBkaWFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbnVtZXJpYyB8fCB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEuZGlhbENvZGUgPT09IG51bWVyaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbElucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2dldE51bWVyaWNcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE51bWVyaWMocykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXEQvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfdHJpZ2dlclwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJpZ2dlcihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gdXNlIG9sZCBzY2hvb2wgZG9jdW1lbnQuY3JlYXRlRXZlbnQgYXMgSUUxMSBkb2Vzbid0IHN1cHBvcnQgYG5ldyBFdmVudCgpYCBzeW50YXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBlLmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGJ1YmJsZSwgYW5kIGlzIGNhbmNlbGxhYmxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9zaG93RHJvcGRvd25cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dEcm9wZG93bigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHJ5TGlzdC5jbGFzc0xpc3QucmVtb3ZlKFwiaXRpX19oaWRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmxhZy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RHJvcGRvd25Qb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaGlnaGxpZ2h0aW5nIGFuZCBzY3JvbGwgdG8gYWN0aXZlIGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWdobGlnaHRMaXN0SXRlbSh0aGlzLmFjdGl2ZUl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuYWN0aXZlSXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYmluZCBhbGwgdGhlIGRyb3Bkb3duLXJlbGF0ZWQgbGlzdGVuZXJzOiBtb3VzZW92ZXIsIGNsaWNrLCBjbGljay1vZmYsIGtleWRvd25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZERyb3Bkb3duTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYXJyb3dcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bkFycm93LmNsYXNzTGlzdC5hZGQoXCJpdGlfX2Fycm93LS11cFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihcIm9wZW46Y291bnRyeWRyb3Bkb3duXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX3RvZ2dsZUNsYXNzXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVDbGFzcyhlbCwgY2xhc3NOYW1lLCBzaG91bGRIYXZlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEhhdmVDbGFzcyAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTsgZWxzZSBpZiAoIXNob3VsZEhhdmVDbGFzcyAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX3NldERyb3Bkb3duUG9zaXRpb25cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldERyb3Bkb3duUG9zaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3Bkb3duQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHJvcGRvd25Db250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kcm9wZG93bik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy50ZWxJbnB1dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvd1RvcCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDM4NDA5MS8yMTc4NjZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dFRvcCA9IHBvcy50b3AgKyB3aW5kb3dUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJvcGRvd25IZWlnaHQgPSB0aGlzLmNvdW50cnlMaXN0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3Bkb3duRml0c0JlbG93ID0gKGRyb3Bkb3duQm90dG9tIDwgd2luZG93Qm90dG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3Bkb3duRml0c0JlbG93ID0gaW5wdXRUb3AgKyB0aGlzLnRlbElucHV0Lm9mZnNldEhlaWdodCArIGRyb3Bkb3duSGVpZ2h0IDwgd2luZG93VG9wICsgd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3Bkb3duRml0c0Fib3ZlID0gaW5wdXRUb3AgLSBkcm9wZG93bkhlaWdodCA+IHdpbmRvd1RvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQsIHRoZSBkcm9wZG93biB3aWxsIGJlIGJlbG93IHRoZSBpbnB1dC4gSWYgd2Ugd2FudCB0byBwb3NpdGlvbiBpdCBhYm92ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlucHV0LCB3ZSBhZGQgdGhlIGRyb3B1cCBjbGFzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUNsYXNzKHRoaXMuY291bnRyeUxpc3QsIFwiaXRpX19jb3VudHJ5LWxpc3QtLWRyb3B1cFwiLCAhZHJvcGRvd25GaXRzQmVsb3cgJiYgZHJvcGRvd25GaXRzQWJvdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgZHJvcGRvd25Db250YWluZXIgaXMgZW5hYmxlZCwgY2FsY3VsYXRlIHBvc3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcGRvd25Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBkZWZhdWx0IHRoZSBkcm9wZG93biB3aWxsIGJlIGRpcmVjdGx5IG92ZXIgdGhlIGlucHV0IGJlY2F1c2UgaXQncyBub3QgaW4gdGhlIGZsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2FudCB0byBwb3NpdGlvbiBpdCBiZWxvdywgd2UgbmVlZCB0byBhZGQgc29tZSBleHRyYSB0b3AgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHJhVG9wID0gIWRyb3Bkb3duRml0c0JlbG93ICYmIGRyb3Bkb3duRml0c0Fib3ZlID8gMCA6IHRoaXMudGVsSW5wdXQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KGlucHV0VG9wICsgZXh0cmFUb3AsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQocG9zLmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgbWVudSBvbiB3aW5kb3cgc2Nyb2xsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlV2luZG93U2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczguX2Nsb3NlRHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Njcm9sbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9nZXRDbG9zZXN0TGlzdEl0ZW1cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENsb3Nlc3RMaXN0SXRlbSh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IHRoaXMuY291bnRyeUxpc3QgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhcIml0aV9fY291bnRyeVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgdGhlIGNvdW50cnlMaXN0IGVsZW1lbnQsIHRoZW4gcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsID09PSB0aGlzLmNvdW50cnlMaXN0ID8gbnVsbCA6IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2JpbmREcm9wZG93bkxpc3RlbmVyc1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZERyb3Bkb3duTGlzdGVuZXJzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM5ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBtb3VzZSBvdmVyIGEgbGlzdCBpdGVtLCBqdXN0IGhpZ2hsaWdodCB0aGF0IG9uZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhZGQgdGhlIGNsYXNzIFwiaGlnaGxpZ2h0XCIsIHNvIGlmIHRoZXkgaGl0IFwiZW50ZXJcIiB3ZSBrbm93IHdoaWNoIG9uZSB0byBzZWxlY3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlTW91c2VvdmVyQ291bnRyeUxpc3QgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZXZlbnQgZGVsZWdhdGlvbiwgYXMgd2UncmUgbGlzdGVuaW5nIGZvciB0aGlzIGV2ZW50IG9uIHRoZSBjb3VudHJ5TGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RJdGVtID0gX3RoaXM5Ll9nZXRDbG9zZXN0TGlzdEl0ZW0oZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RJdGVtKSBfdGhpczkuX2hpZ2hsaWdodExpc3RJdGVtKGxpc3RJdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRyeUxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLl9oYW5kbGVNb3VzZW92ZXJDb3VudHJ5TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbiBmb3IgY291bnRyeSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2xpY2tDb3VudHJ5TGlzdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0SXRlbSA9IF90aGlzOS5fZ2V0Q2xvc2VzdExpc3RJdGVtKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXN0SXRlbSkgX3RoaXM5Ll9zZWxlY3RMaXN0SXRlbShsaXN0SXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnRyeUxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZUNsaWNrQ291bnRyeUxpc3QpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGljayBvZmYgdG8gY2xvc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gKGV4Y2VwdCB3aGVuIHRoaXMgaW5pdGlhbCBvcGVuaW5nIGNsaWNrIGlzIGJ1YmJsaW5nIHVwKVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QganVzdCBzdG9wUHJvcGFnYXRpb24gYXMgaXQgbWF5IGJlIG5lZWRlZCB0byBjbG9zZSBhbm90aGVyIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc09wZW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVDbGlja09mZlRvQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNPcGVuaW5nKSBfdGhpczkuX2Nsb3NlRHJvcGRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3BlbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZUNsaWNrT2ZmVG9DbG9zZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbiBmb3IgdXAvZG93biBzY3JvbGxpbmcsIGVudGVyIHRvIHNlbGVjdCwgb3IgbGV0dGVycyB0byBqdW1wIHRvIGNvdW50cnkgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGtleWRvd24gYXMga2V5cHJlc3MgZG9lc24ndCBmaXJlIGZvciBub24tY2hhciBrZXlzIGFuZCB3ZSB3YW50IHRvIGNhdGNoIGlmIHRoZXlcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBoaXQgZG93biBhbmQgaG9sZCBpdCB0byBzY3JvbGwgZG93biAobm8ga2V5dXAgZXZlbnQpLlxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gb24gdGhlIGRvY3VtZW50IGJlY2F1c2UgdGhhdCdzIHdoZXJlIGtleSBldmVudHMgYXJlIHRyaWdnZXJlZCBpZiBubyBpbnB1dCBoYXMgZm9jdXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5VGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVLZXlkb3duT25Ecm9wZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZG93biBrZXkgZnJvbSBzY3JvbGxpbmcgdGhlIHdob2xlIHBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZW50ZXIga2V5IGZyb20gc3VibWl0dGluZyBhIGZvcm0gZXRjXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cCBhbmQgZG93biB0byBuYXZpZ2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5ID09PSBcIkFycm93VXBcIiB8fCBlLmtleSA9PT0gXCJVcFwiIHx8IGUua2V5ID09PSBcIkFycm93RG93blwiIHx8IGUua2V5ID09PSBcIkRvd25cIikgX3RoaXM5Ll9oYW5kbGVVcERvd25LZXkoZS5rZXkpOyBlbHNlIGlmIChlLmtleSA9PT0gXCJFbnRlclwiKSBfdGhpczkuX2hhbmRsZUVudGVyS2V5KCk7IGVsc2UgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSBfdGhpczkuX2Nsb3NlRHJvcGRvd24oKTsgZWxzZSBpZiAoL15bYS16QS1aw4Atw7/QsC3Rj9CQLdCvIF0kLy50ZXN0KGUua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1bXAgdG8gY291bnRyaWVzIHRoYXQgc3RhcnQgd2l0aCB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5VGltZXIpIGNsZWFyVGltZW91dChxdWVyeVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSArPSBlLmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzOS5fc2VhcmNoRm9yQ291bnRyeShxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRpbWVyIGhpdHMgMSBzZWNvbmQsIHJlc2V0IHRoZSBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMWUzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5faGFuZGxlS2V5ZG93bk9uRHJvcGRvd24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2hhbmRsZVVwRG93bktleVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVXBEb3duS2V5KGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGtleSA9PT0gXCJBcnJvd1VwXCIgfHwga2V5ID09PSBcIlVwXCIgPyB0aGlzLmhpZ2hsaWdodGVkSXRlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIDogdGhpcy5oaWdobGlnaHRlZEl0ZW0ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgZGl2aWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXRpX19kaXZpZGVyXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGtleSA9PT0gXCJBcnJvd1VwXCIgfHwga2V5ID09PSBcIlVwXCIgPyBuZXh0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgOiBuZXh0Lm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodExpc3RJdGVtKG5leHQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfaGFuZGxlRW50ZXJLZXlcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUVudGVyS2V5KCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRlZEl0ZW0pIHRoaXMuX3NlbGVjdExpc3RJdGVtKHRoaXMuaGlnaGxpZ2h0ZWRJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9zZWFyY2hGb3JDb3VudHJ5XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZWFyY2hGb3JDb3VudHJ5KHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb3VudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydHNXaXRoKHRoaXMuY291bnRyaWVzW2ldLm5hbWUsIHF1ZXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0SXRlbSA9IHRoaXMuY291bnRyeUxpc3QucXVlcnlTZWxlY3RvcihcIiNpdGktXCIuY29uY2F0KHRoaXMuaWQsIFwiX19pdGVtLVwiKS5jb25jYXQodGhpcy5jb3VudHJpZXNbaV0uaXNvMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBoaWdobGlnaHRpbmcgYW5kIHNjcm9sbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodExpc3RJdGVtKGxpc3RJdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVG8obGlzdEl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfc3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRzV2l0aChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnN1YnN0cigwLCBiLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl91cGRhdGVWYWxGcm9tTnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVWYWxGcm9tTnVtYmVyKG9yaWdpbmFsTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1iZXIgPSBvcmlnaW5hbE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JtYXRPbkRpc3BsYXkgJiYgd2luZG93LmludGxUZWxJbnB1dFV0aWxzICYmIHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZU5hdGlvbmFsID0gIXRoaXMub3B0aW9ucy5zZXBhcmF0ZURpYWxDb2RlICYmICh0aGlzLm9wdGlvbnMubmF0aW9uYWxNb2RlIHx8IG51bWJlci5jaGFyQXQoMCkgIT09IFwiK1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaW50bFRlbElucHV0VXRpbHMkbnUgPSBpbnRsVGVsSW5wdXRVdGlscy5udW1iZXJGb3JtYXQsIE5BVElPTkFMID0gX2ludGxUZWxJbnB1dFV0aWxzJG51Lk5BVElPTkFMLCBJTlRFUk5BVElPTkFMID0gX2ludGxUZWxJbnB1dFV0aWxzJG51LklOVEVSTkFUSU9OQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0ID0gdXNlTmF0aW9uYWwgPyBOQVRJT05BTCA6IElOVEVSTkFUSU9OQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgPSBpbnRsVGVsSW5wdXRVdGlscy5mb3JtYXROdW1iZXIobnVtYmVyLCB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEuaXNvMiwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBudW1iZXIgPSB0aGlzLl9iZWZvcmVTZXROdW1iZXIobnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZWxJbnB1dC52YWx1ZSA9IG51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl91cGRhdGVGbGFnRnJvbU51bWJlclwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRmxhZ0Zyb21OdW1iZXIob3JpZ2luYWxOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgaW4gbmF0aW9uYWxNb2RlIGFuZCB3ZSBhbHJlYWR5IGhhdmUgVVMvQ2FuYWRhIHNlbGVjdGVkLCBtYWtlIHN1cmUgdGhlIG51bWJlciBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBhICsxIHNvIF9nZXREaWFsQ29kZSB3aWxsIGJlIGFibGUgdG8gZXh0cmFjdCB0aGUgYXJlYSBjb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZTogaWYgd2UgZG9udCB5ZXQgaGF2ZSBzZWxlY3RlZENvdW50cnlEYXRhLCBidXQgd2UncmUgaGVyZSAodHJ5aW5nIHRvIHVwZGF0ZSB0aGUgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBudW1iZXIpLCB0aGF0IG1lYW5zIHdlJ3JlIGluaXRpYWxpc2luZyB0aGUgcGx1Z2luIHdpdGggYSBudW1iZXIgdGhhdCBhbHJlYWR5IGhhcyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpYWwgY29kZSwgc28gZmluZSB0byBpZ25vcmUgdGhpcyBiaXRcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlciA9IG9yaWdpbmFsTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWREaWFsQ29kZSA9IHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YS5kaWFsQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTmFucCA9IHNlbGVjdGVkRGlhbENvZGUgPT09IFwiMVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtYmVyICYmIHRoaXMub3B0aW9ucy5uYXRpb25hbE1vZGUgJiYgaXNOYW5wICYmIG51bWJlci5jaGFyQXQoMCkgIT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtYmVyLmNoYXJBdCgwKSAhPT0gXCIxXCIpIG51bWJlciA9IFwiMVwiLmNvbmNhdChudW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gXCIrXCIuY29uY2F0KG51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZsYWcgaWYgdXNlciB0eXBlcyBhcmVhIGNvZGUgZm9yIGFub3RoZXIgY291bnRyeVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlcGFyYXRlRGlhbENvZGUgJiYgc2VsZWN0ZWREaWFsQ29kZSAmJiBudW1iZXIuY2hhckF0KDApICE9PSBcIitcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gXCIrXCIuY29uY2F0KHNlbGVjdGVkRGlhbENvZGUpLmNvbmNhdChudW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSBhbmQgZXh0cmFjdCB2YWxpZCBkaWFsIGNvZGUgZnJvbSBpbnB1dFxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlhbENvZGUgPSB0aGlzLl9nZXREaWFsQ29kZShudW1iZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtZXJpYyA9IHRoaXMuX2dldE51bWVyaWMobnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50cnlDb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpYWxDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGVzID0gdGhpcy5jb3VudHJ5Q29kZXNbdGhpcy5fZ2V0TnVtZXJpYyhkaWFsQ29kZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHJpZ2h0IGNvdW50cnkgaXMgYWxyZWFkeSBzZWxlY3RlZC4gdGhpcyBzaG91bGQgYmUgZmFsc2UgaWYgdGhlIG51bWJlciBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIG1hdGNoZWQgZGlhbCBjb2RlIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgaWZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBtdWx0aXBsZSBjb3VudHJ5IG1hdGNoZXMsIHRoYXQgdGhlIGZpcnN0IG9uZSBpcyBzZWxlY3RlZCAobm90ZTogd2UgY291bGRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgY2hlY2sgdGhhdCBoZXJlLCBidXQgaXQgcmVxdWlyZXMgdGhlIHNhbWUgbG9vcCB0aGF0IHdlIGFscmVhZHkgaGF2ZSBsYXRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSBjb3VudHJ5Q29kZXMuaW5kZXhPZih0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEuaXNvMikgIT09IC0xICYmIG51bWVyaWMubGVuZ3RoIDw9IGRpYWxDb2RlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNSZWdpb25sZXNzTmFucE51bWJlciA9IHNlbGVjdGVkRGlhbENvZGUgPT09IFwiMVwiICYmIHRoaXMuX2lzUmVnaW9ubGVzc05hbnAobnVtZXJpYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0aGUgZmxhZyBpZjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEpIE5PVCAod2UgY3VycmVudGx5IGhhdmUgYSBOQU5QIGZsYWcgc2VsZWN0ZWQsIGFuZCB0aGUgbnVtYmVyIGlzIGEgcmVnaW9ubGVzc05hbnApXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBTkRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEIpIHRoZSByaWdodCBjb3VudHJ5IGlzIG5vdCBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVnaW9ubGVzc05hbnBOdW1iZXIgJiYgIWFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVzaW5nIG9ubHlDb3VudHJpZXMgb3B0aW9uLCBjb3VudHJ5Q29kZXNbMF0gbWF5IGJlIGVtcHR5LCBzbyB3ZSBtdXN0IGZpbmQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9uLWVtcHR5IGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudHJ5Q29kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50cnlDb2Rlc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRyeUNvZGUgPSBjb3VudHJ5Q29kZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW1iZXIuY2hhckF0KDApID09PSBcIitcIiAmJiBudW1lcmljLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZCBkaWFsIGNvZGUsIHNvIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiB1c2UgZ2V0TnVtZXJpYyBoZXJlIGJlY2F1c2UgdGhlIG51bWJlciBoYXMgbm90IGJlZW4gZm9ybWF0dGVkIHlldCwgc28gY291bGQgY29udGFpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFkIGNoYXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudHJ5Q29kZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW51bWJlciB8fCBudW1iZXIgPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eSwgb3IganVzdCBhIHBsdXMsIHNvIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50cnlDb2RlID0gdGhpcy5kZWZhdWx0Q291bnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRyeUNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRGbGFnKGNvdW50cnlDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfaXNSZWdpb25sZXNzTmFucFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNSZWdpb25sZXNzTmFucChudW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bWVyaWMgPSB0aGlzLl9nZXROdW1lcmljKG51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1lcmljLmNoYXJBdCgwKSA9PT0gXCIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmVhQ29kZSA9IG51bWVyaWMuc3Vic3RyKDEsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lvbmxlc3NOYW5wTnVtYmVycy5pbmRleE9mKGFyZWFDb2RlKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2hpZ2hsaWdodExpc3RJdGVtXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWdobGlnaHRMaXN0SXRlbShsaXN0SXRlbSwgc2hvdWxkRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZJdGVtID0gdGhpcy5oaWdobGlnaHRlZEl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2SXRlbSkgcHJldkl0ZW0uY2xhc3NMaXN0LnJlbW92ZShcIml0aV9faGlnaGxpZ2h0XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSXRlbSA9IGxpc3RJdGVtO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSXRlbS5jbGFzc0xpc3QuYWRkKFwiaXRpX19oaWdobGlnaHRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRGb2N1cykgdGhpcy5oaWdobGlnaHRlZEl0ZW0uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9nZXRDb3VudHJ5RGF0YVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q291bnRyeURhdGEoY291bnRyeUNvZGUsIGlnbm9yZU9ubHlDb3VudHJpZXNPcHRpb24sIGFsbG93RmFpbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRyeUxpc3QgPSBpZ25vcmVPbmx5Q291bnRyaWVzT3B0aW9uID8gYWxsQ291bnRyaWVzIDogdGhpcy5jb3VudHJpZXM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnRyeUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudHJ5TGlzdFtpXS5pc28yID09PSBjb3VudHJ5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3VudHJ5TGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dGYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb3VudHJ5IGRhdGEgZm9yICdcIi5jb25jYXQoY291bnRyeUNvZGUsIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfc2V0RmxhZ1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0RmxhZyhjb3VudHJ5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldkNvdW50cnkgPSB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEuaXNvMiA/IHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyB0aGlzIGZpcnN0IGFzIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgYW5kIHN0b3AgaWYgY291bnRyeUNvZGUgaXMgaW52YWxpZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEgPSBjb3VudHJ5Q29kZSA/IHRoaXMuX2dldENvdW50cnlEYXRhKGNvdW50cnlDb2RlLCBmYWxzZSwgZmFsc2UpIDoge307XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZGVmYXVsdENvdW50cnkgLSB3ZSBvbmx5IG5lZWQgdGhlIGlzbzIgZnJvbSBub3cgb24sIHNvIGp1c3Qgc3RvcmUgdGhhdFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmlzbzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdENvdW50cnkgPSB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEuaXNvMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmxhZ0lubmVyLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiaXRpX19mbGFnIGl0aV9fXCIuY29uY2F0KGNvdW50cnlDb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgY291bnRyeSdzIHRpdGxlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBjb3VudHJ5Q29kZSA/IFwiXCIuY29uY2F0KHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YS5uYW1lLCBcIjogK1wiKS5jb25jYXQodGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmRpYWxDb2RlKSA6IFwiVW5rbm93blwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmxhZy5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCB0aXRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VwYXJhdGVEaWFsQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWxDb2RlID0gdGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmRpYWxDb2RlID8gXCIrXCIuY29uY2F0KHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YS5kaWFsQ29kZSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERpYWxDb2RlLmlubmVySFRNTCA9IGRpYWxDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0V2lkdGggaXMgemVybyBpZiBpbnB1dCBpcyBpbiBhIGhpZGRlbiBjb250YWluZXIgZHVyaW5nIGluaXRpYWxpc2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRGbGFnV2lkdGggPSB0aGlzLnNlbGVjdGVkRmxhZy5vZmZzZXRXaWR0aCB8fCB0aGlzLl9nZXRIaWRkZW5TZWxlY3RlZEZsYWdXaWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIDZweCBvZiBwYWRkaW5nIGFmdGVyIHRoZSBncmV5IHNlbGVjdGVkLWRpYWwtY29kZSBib3gsIGFzIHRoaXMgaXMgd2hhdCB3ZSB1c2UgaW4gdGhlIGNzc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZWxJbnB1dC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiXCIuY29uY2F0KHNlbGVjdGVkRmxhZ1dpZHRoICsgNiwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIGlucHV0J3MgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBhY3RpdmUgbGlzdCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dEcm9wZG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZJdGVtID0gdGhpcy5hY3RpdmVJdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkl0ZW0uY2xhc3NMaXN0LnJlbW92ZShcIml0aV9fYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZJdGVtLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudHJ5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgcHJlZmVycmVkIGl0ZW0gZmlyc3QsIGVsc2UgZmFsbCBiYWNrIHRvIHN0YW5kYXJkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRJdGVtID0gdGhpcy5jb3VudHJ5TGlzdC5xdWVyeVNlbGVjdG9yKFwiI2l0aS1cIi5jb25jYXQodGhpcy5pZCwgXCJfX2l0ZW0tXCIpLmNvbmNhdChjb3VudHJ5Q29kZSwgXCItcHJlZmVycmVkXCIpKSB8fCB0aGlzLmNvdW50cnlMaXN0LnF1ZXJ5U2VsZWN0b3IoXCIjaXRpLVwiLmNvbmNhdCh0aGlzLmlkLCBcIl9faXRlbS1cIikuY29uY2F0KGNvdW50cnlDb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEl0ZW0uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEl0ZW0uY2xhc3NMaXN0LmFkZChcIml0aV9fYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IG5leHRJdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGbGFnLnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBuZXh0SXRlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGlmIHRoZSBmbGFnIGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkNvdW50cnkuaXNvMiAhPT0gY291bnRyeUNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfZ2V0SGlkZGVuU2VsZWN0ZWRGbGFnV2lkdGhcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEhpZGRlblNlbGVjdGVkRmxhZ1dpZHRoKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0byBnZXQgdGhlIHJpZ2h0IHN0eWxpbmcgdG8gYXBwbHksIGFsbCB3ZSBuZWVkIGlzIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiB0byBpbmplY3QgYSBkZWVwIGNsb25lIG9mIHRoZSBzZWxlY3RlZEZsYWcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyQ2xvbmUgPSB0aGlzLnRlbElucHV0LnBhcmVudE5vZGUuY2xvbmVOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckNsb25lLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lckNsb25lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWdzQ29udGFpbmVyQ2xvbmUgPSB0aGlzLmZsYWdzQ29udGFpbmVyLmNsb25lTm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJDbG9uZS5hcHBlbmRDaGlsZChmbGFnc0NvbnRhaW5lckNsb25lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkRmxhZ0Nsb25lID0gdGhpcy5zZWxlY3RlZEZsYWcuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBmbGFnc0NvbnRhaW5lckNsb25lLmFwcGVuZENoaWxkKHNlbGVjdGVkRmxhZ0Nsb25lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gc2VsZWN0ZWRGbGFnQ2xvbmUub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lckNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29udGFpbmVyQ2xvbmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfdXBkYXRlUGxhY2Vob2xkZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVBsYWNlaG9sZGVyKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkU2V0UGxhY2Vob2xkZXIgPSB0aGlzLm9wdGlvbnMuYXV0b1BsYWNlaG9sZGVyID09PSBcImFnZ3Jlc3NpdmVcIiB8fCAhdGhpcy5oYWRJbml0aWFsUGxhY2Vob2xkZXIgJiYgdGhpcy5vcHRpb25zLmF1dG9QbGFjZWhvbGRlciA9PT0gXCJwb2xpdGVcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5pbnRsVGVsSW5wdXRVdGlscyAmJiBzaG91bGRTZXRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlclR5cGUgPSBpbnRsVGVsSW5wdXRVdGlscy5udW1iZXJUeXBlW3RoaXMub3B0aW9ucy5wbGFjZWhvbGRlck51bWJlclR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gdGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmlzbzIgPyBpbnRsVGVsSW5wdXRVdGlscy5nZXRFeGFtcGxlTnVtYmVyKHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YS5pc28yLCB0aGlzLm9wdGlvbnMubmF0aW9uYWxNb2RlLCBudW1iZXJUeXBlKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlciA9IHRoaXMuX2JlZm9yZVNldE51bWJlcihwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jdXN0b21QbGFjZWhvbGRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLm9wdGlvbnMuY3VzdG9tUGxhY2Vob2xkZXIocGxhY2Vob2xkZXIsIHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbElucHV0LnNldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX3NlbGVjdExpc3RJdGVtXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZWxlY3RMaXN0SXRlbShsaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgc2VsZWN0ZWQgZmxhZyBhbmQgYWN0aXZlIGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ0NoYW5nZWQgPSB0aGlzLl9zZXRGbGFnKGxpc3RJdGVtLmdldEF0dHJpYnV0ZShcImRhdGEtY291bnRyeS1jb2RlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VEcm9wZG93bigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVEaWFsQ29kZShsaXN0SXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWRpYWwtY29kZVwiKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvY3VzIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1dCBjdXJzb3IgYXQgZW5kIC0gdGhpcyBmaXggaXMgcmVxdWlyZWQgZm9yIEZGIGFuZCBJRTExICh3aXRoIG5hdGlvbmFsTW9kZT1mYWxzZSBpLmUuIGF1dG9cbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0aW5nIGRpYWwgY29kZSksIHdobyB0cnkgdG8gcHV0IHRoZSBjdXJzb3IgYXQgdGhlIGJlZ2lubmluZyB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gdGhpcy50ZWxJbnB1dC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuLCBsZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJDb3VudHJ5Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl9jbG9zZURyb3Bkb3duXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZURyb3Bkb3duKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50cnlMaXN0LmNsYXNzTGlzdC5hZGQoXCJpdGlfX2hpZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGbGFnLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBhcnJvd1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duQXJyb3cuY2xhc3NMaXN0LnJlbW92ZShcIml0aV9fYXJyb3ctLXVwXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmJpbmQga2V5IGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVLZXlkb3duT25Ecm9wZG93bik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlQ2xpY2tPZmZUb0Nsb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHJ5TGlzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMuX2hhbmRsZU1vdXNlb3ZlckNvdW50cnlMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudHJ5TGlzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlQ2xpY2tDb3VudHJ5TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBtZW51IGZyb20gY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcGRvd25Db250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc01vYmlsZSkgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5faGFuZGxlV2luZG93U2Nyb2xsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyb3Bkb3duLnBhcmVudE5vZGUpIHRoaXMuZHJvcGRvd24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRyb3Bkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwiY2xvc2U6Y291bnRyeWRyb3Bkb3duXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX3Njcm9sbFRvXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zY3JvbGxUbyhlbGVtZW50LCBtaWRkbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY291bnRyeUxpc3Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvd1RvcCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDM4NDA5MS8yMTc4NjZcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd1RvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lclRvcCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB3aW5kb3dUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJCb3R0b20gPSBjb250YWluZXJUb3AgKyBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50VG9wID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB3aW5kb3dUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50Qm90dG9tID0gZWxlbWVudFRvcCArIGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTY3JvbGxUb3AgPSBlbGVtZW50VG9wIC0gY29udGFpbmVyVG9wICsgY29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pZGRsZU9mZnNldCA9IGNvbnRhaW5lckhlaWdodCAvIDIgLSBlbGVtZW50SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRUb3AgPCBjb250YWluZXJUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjcm9sbCB1cFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pZGRsZSkgbmV3U2Nyb2xsVG9wIC09IG1pZGRsZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBuZXdTY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudEJvdHRvbSA+IGNvbnRhaW5lckJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaWRkbGUpIG5ld1Njcm9sbFRvcCArPSBtaWRkbGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0RGlmZmVyZW5jZSA9IGNvbnRhaW5lckhlaWdodCAtIGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gbmV3U2Nyb2xsVG9wIC0gaGVpZ2h0RGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX3VwZGF0ZURpYWxDb2RlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVEaWFsQ29kZShuZXdEaWFsQ29kZUJhcmUsIGhhc1NlbGVjdGVkTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0VmFsID0gdGhpcy50ZWxJbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBoYXZpbmcgdG8gcGFzcyB0aGlzIGV2ZXJ5IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0RpYWxDb2RlID0gXCIrXCIuY29uY2F0KG5ld0RpYWxDb2RlQmFyZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbC5jaGFyQXQoMCkgPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIGEgcGx1cyBzbyB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZXBsYWNlbWVudCAoZG9lc24ndCBtYXR0ZXIgaWYgbmF0aW9uYWxNb2RlIG9yIG5vdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2RGlhbENvZGUgPSB0aGlzLl9nZXREaWFsQ29kZShpbnB1dFZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkRpYWxDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBudW1iZXIgY29udGFpbnMgYSB2YWxpZCBkaWFsIGNvZGUsIHNvIHJlcGxhY2UgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOdW1iZXIgPSBpbnB1dFZhbC5yZXBsYWNlKHByZXZEaWFsQ29kZSwgbmV3RGlhbENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IG51bWJlciBjb250YWlucyBhbiBpbnZhbGlkIGRpYWwgY29kZSwgc28gZGl0Y2ggaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAobm8gd2F5IHRvIGRldGVybWluZSB3aGVyZSB0aGUgaW52YWxpZCBkaWFsIGNvZGUgZW5kcyBhbmQgdGhlIHJlc3Qgb2YgdGhlIG51bWJlciBiZWdpbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TnVtYmVyID0gbmV3RGlhbENvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm5hdGlvbmFsTW9kZSB8fCB0aGlzLm9wdGlvbnMuc2VwYXJhdGVEaWFsQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5hdGlvbmFsTW9kZSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgYW4gZXhpc3RpbmcgdmFsdWUgd2l0aCBubyBkaWFsIGNvZGU6IHByZWZpeCB0aGUgbmV3IGRpYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld051bWJlciA9IG5ld0RpYWxDb2RlICsgaW5wdXRWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1NlbGVjdGVkTGlzdEl0ZW0gfHwgIXRoaXMub3B0aW9ucy5hdXRvSGlkZURpYWxDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZXhpc3RpbmcgdmFsdWUgYW5kIGVpdGhlciB0aGV5J3ZlIGp1c3Qgc2VsZWN0ZWQgYSBsaXN0IGl0ZW0sIG9yIGF1dG9IaWRlRGlhbENvZGUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZDogaW5zZXJ0IG5ldyBkaWFsIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOdW1iZXIgPSBuZXdEaWFsQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQudmFsdWUgPSBuZXdOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfZ2V0RGlhbENvZGVcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpYWxDb2RlKG51bWJlciwgaW5jbHVkZUFyZWFDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWFsQ29kZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBpbnRlcm5hdGlvbmFsIG51bWJlcnMgKHN0YXJ0aW5nIHdpdGggYSBwbHVzKVxuICAgICAgICAgICAgICAgICAgICBpZiAobnVtYmVyLmNoYXJBdCgwKSA9PT0gXCIrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1lcmljQ2hhcnMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGNoYXJzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbnVtYmVyLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjaGFyIGlzIG51bWJlciAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5MzU2NDkvMjE3ODY2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoYywgMTApKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1lcmljQ2hhcnMgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudCBudW1lcmljQ2hhcnMgbWFrZSBhIHZhbGlkIGRpYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUFyZWFDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudHJ5Q29kZXNbbnVtZXJpY0NoYXJzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBhY3R1YWwgcmF3IHN0cmluZyAodXNlZnVsIGZvciBtYXRjaGluZyBsYXRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsQ29kZSA9IG51bWJlci5zdWJzdHIoMCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlhbENvZGVzW251bWVyaWNDaGFyc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsQ29kZSA9IG51bWJlci5zdWJzdHIoMCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGp1c3QgbG9va2luZyBmb3IgYSBkaWFsIGNvZGUsIHdlIGNhbiBicmVhayBhcyBzb29uIGFzIHdlIGZpbmQgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzZWFyY2hpbmcgYXMgc29vbiBhcyB3ZSBjYW4gLSBpbiB0aGlzIGNhc2Ugd2hlbiB3ZSBoaXQgbWF4IGxlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtZXJpY0NoYXJzLmxlbmd0aCA9PT0gdGhpcy5jb3VudHJ5Q29kZU1heExlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpYWxDb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiX2dldEZ1bGxOdW1iZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZ1bGxOdW1iZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnRlbElucHV0LnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWxDb2RlID0gdGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmRpYWxDb2RlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlZml4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtZXJpY1ZhbCA9IHRoaXMuX2dldE51bWVyaWModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZXBhcmF0ZURpYWxDb2RlICYmIHZhbC5jaGFyQXQoMCkgIT09IFwiK1wiICYmIGRpYWxDb2RlICYmIG51bWVyaWNWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgc2VwYXJhdGVEaWFsQ29kZSwgaXQgaXMgdmlzaWJsZSBzbyBpcyBlZmZlY3RpdmVseSBwYXJ0IG9mIHRoZSB0eXBlZCBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiK1wiLmNvbmNhdChkaWFsQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJfYmVmb3JlU2V0TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iZWZvcmVTZXROdW1iZXIob3JpZ2luYWxOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bWJlciA9IG9yaWdpbmFsTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNlcGFyYXRlRGlhbENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWFsQ29kZSA9IHRoaXMuX2dldERpYWxDb2RlKG51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHZhbGlkIGRpYWwgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpYWxDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSBfZ2V0RGlhbENvZGUgcmV0dXJuZWQgYW4gYXJlYSBjb2RlIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFsQ29kZSA9IFwiK1wiLmNvbmNhdCh0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEuZGlhbENvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgbG90IG9mIG51bWJlcnMgd2lsbCBoYXZlIGEgc3BhY2Ugc2VwYXJhdGluZyB0aGUgZGlhbCBjb2RlIGFuZCB0aGUgbWFpbiBudW1iZXIsIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvbWUgTkFOUCBudW1iZXJzIHdpbGwgaGF2ZSBhIGh5cGhlbiBlLmcuICsxIDY4NC03MzMtMTIzNCAtIGluIGJvdGggY2FzZXMgd2Ugd2FudCB0byBnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByaWQgb2YgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBkb24ndCBqdXN0IHRyaW0gYWxsIG5vbi1udW1lcmljcyBhcyBtYXkgd2FudCB0byBwcmVzZXJ2ZSBhbiBvcGVuIHBhcmVudGhlc2lzIGV0Y1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IG51bWJlcltkaWFsQ29kZS5sZW5ndGhdID09PSBcIiBcIiB8fCBudW1iZXJbZGlhbENvZGUubGVuZ3RoXSA9PT0gXCItXCIgPyBkaWFsQ29kZS5sZW5ndGggKyAxIDogZGlhbENvZGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciA9IG51bWJlci5zdWJzdHIoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXAobnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcIl90cmlnZ2VyQ291bnRyeUNoYW5nZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJpZ2dlckNvdW50cnlDaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXCJjb3VudHJ5Y2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiaGFuZGxlQXV0b0NvdW50cnlcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQXV0b0NvdW50cnkoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbENvdW50cnkgPT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IHNldCB0aGlzIGV2ZW4gaWYgdGhlcmUgaXMgYW4gaW5pdGlhbCB2YWwgaW4gdGhlIGlucHV0OiBpbiBjYXNlIHRoZSBpbml0aWFsIHZhbCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52YWxpZCBhbmQgdGhleSBkZWxldGUgaXQgLSB0aGV5IHNob3VsZCBzZWUgdGhlaXIgYXV0byBjb3VudHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRDb3VudHJ5ID0gd2luZG93LmludGxUZWxJbnB1dEdsb2JhbHMuYXV0b0NvdW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG5vIGluaXRpYWwgdmFsdWUgaW4gdGhlIGlucHV0LCB0aGVuIHVwZGF0ZSB0aGUgZmxhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRlbElucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb3VudHJ5KHRoaXMuZGVmYXVsdENvdW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlQXV0b0NvdW50cnlQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcImhhbmRsZVV0aWxzXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVV0aWxzKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmludGxUZWxJbnB1dFV0aWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGFuIGluaXRpYWwgdmFsdWUgaW4gdGhlIGlucHV0LCB0aGVuIGZvcm1hdCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGVsSW5wdXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVWYWxGcm9tTnVtYmVyKHRoaXMudGVsSW5wdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUGxhY2Vob2xkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVVdGlsc1NjcmlwdFByb21pc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm0gPSB0aGlzLnRlbElucHV0LmZvcm07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dEcm9wZG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBkcm9wZG93biBpcyBjbG9zZWQgKGFuZCB1bmJpbmQgbGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VEcm9wZG93bigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZsYWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZUNsaWNrU2VsZWN0ZWRGbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhZ3NDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5faGFuZGxlRmxhZ3NDb250YWluZXJLZXlkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxhYmVsIGNsaWNrIGhhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMuX2dldENsb3Nlc3RMYWJlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsKSBsYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlTGFiZWxDbGljayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdW5iaW5kIGhpZGRlbklucHV0IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWRkZW5JbnB1dCAmJiBmb3JtKSBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgdGhpcy5faGFuZGxlSGlkZGVuSW5wdXRTdWJtaXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmJpbmQgYXV0b0hpZGVEaWFsQ29kZSBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGlkZURpYWxDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybSkgZm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMuX2hhbmRsZVN1Ym1pdE9yQmx1ckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5faGFuZGxlU3VibWl0T3JCbHVyRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHVuYmluZCBrZXkgZXZlbnRzLCBhbmQgY3V0L3Bhc3RlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLl9oYW5kbGVLZXl1cEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZWxJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuX2hhbmRsZUNsaXBib2FyZEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZWxJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy5faGFuZGxlQ2xpcGJvYXJkRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgYXR0cmlidXRlIG9mIGlkIGluc3RhbmNlOiBkYXRhLWludGwtdGVsLWlucHV0LWlkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVsSW5wdXQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1pbnRsLXRlbC1pbnB1dC1pZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG1hcmt1cCAoYnV0IGxlYXZlIHRoZSBvcmlnaW5hbCBpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLnRlbElucHV0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy50ZWxJbnB1dCwgd3JhcHBlcik7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5pbnRsVGVsSW5wdXRHbG9iYWxzLmluc3RhbmNlc1t0aGlzLmlkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAga2V5OiBcImdldEV4dGVuc2lvblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFeHRlbnNpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaW50bFRlbElucHV0VXRpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRsVGVsSW5wdXRVdGlscy5nZXRFeHRlbnNpb24odGhpcy5fZ2V0RnVsbE51bWJlcigpLCB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEuaXNvMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJnZXROdW1iZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TnVtYmVyKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmludGxUZWxJbnB1dFV0aWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNvMiA9IHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YS5pc28yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGxUZWxJbnB1dFV0aWxzLmZvcm1hdE51bWJlcih0aGlzLl9nZXRGdWxsTnVtYmVyKCksIGlzbzIsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJnZXROdW1iZXJUeXBlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWJlclR5cGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuaW50bFRlbElucHV0VXRpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRsVGVsSW5wdXRVdGlscy5nZXROdW1iZXJUeXBlKHRoaXMuX2dldEZ1bGxOdW1iZXIoKSwgdGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmlzbzIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtOTk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJnZXRTZWxlY3RlZENvdW50cnlEYXRhXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkQ291bnRyeURhdGEoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJnZXRWYWxpZGF0aW9uRXJyb3JcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbkVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmludGxUZWxJbnB1dFV0aWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNvMiA9IHRoaXMuc2VsZWN0ZWRDb3VudHJ5RGF0YS5pc28yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGxUZWxJbnB1dFV0aWxzLmdldFZhbGlkYXRpb25FcnJvcih0aGlzLl9nZXRGdWxsTnVtYmVyKCksIGlzbzIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtOTk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJpc1ZhbGlkTnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWROdW1iZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLl9nZXRGdWxsTnVtYmVyKCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSB0aGlzLm9wdGlvbnMubmF0aW9uYWxNb2RlID8gdGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmlzbzIgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmludGxUZWxJbnB1dFV0aWxzID8gaW50bFRlbElucHV0VXRpbHMuaXNWYWxpZE51bWJlcih2YWwsIGNvdW50cnlDb2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJzZXRDb3VudHJ5XCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvdW50cnkob3JpZ2luYWxDb3VudHJ5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRyeUNvZGUgPSBvcmlnaW5hbENvdW50cnlDb2RlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkRmxhZ0lubmVyLmNsYXNzTGlzdC5jb250YWlucyhcIml0aV9fXCIuY29uY2F0KGNvdW50cnlDb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEZsYWcoY291bnRyeUNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlhbENvZGUodGhpcy5zZWxlY3RlZENvdW50cnlEYXRhLmRpYWxDb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ291bnRyeUNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtleTogXCJzZXROdW1iZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TnVtYmVyKG51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IHVwZGF0ZSB0aGUgZmxhZyBmaXJzdCwgd2hpY2ggdXBkYXRlcyB0aGlzLnNlbGVjdGVkQ291bnRyeURhdGEsIHdoaWNoIGlzIHVzZWQgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdHRpbmcgdGhlIG51bWJlciBiZWZvcmUgZGlzcGxheWluZyBpdFxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZ0NoYW5nZWQgPSB0aGlzLl91cGRhdGVGbGFnRnJvbU51bWJlcihudW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVWYWxGcm9tTnVtYmVyKG51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFnQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckNvdW50cnlDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwic2V0UGxhY2Vob2xkZXJOdW1iZXJUeXBlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBsYWNlaG9sZGVyTnVtYmVyVHlwZSh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlck51bWJlclR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQbGFjZWhvbGRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXSk7XG4gICAgICAgICAgICByZXR1cm4gSXRpO1xuICAgICAgICB9KCk7XG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKlxuICogIFNUQVRJQyBNRVRIT0RTXG4gKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8vIGdldCB0aGUgY291bnRyeSBkYXRhIG9iamVjdFxuICAgICAgICBpbnRsVGVsSW5wdXRHbG9iYWxzLmdldENvdW50cnlEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxsQ291bnRyaWVzO1xuICAgICAgICB9O1xuICAgICAgICAvLyBpbmplY3QgYSA8c2NyaXB0PiBlbGVtZW50IHRvIGxvYWQgdXRpbHMuanNcbiAgICAgICAgdmFyIGluamVjdFNjcmlwdCA9IGZ1bmN0aW9uIGluamVjdFNjcmlwdChwYXRoLCBoYW5kbGVTdWNjZXNzLCBoYW5kbGVGYWlsdXJlKSB7XG4gICAgICAgICAgICAvLyBpbmplY3QgYSBuZXcgc2NyaXB0IGVsZW1lbnQgaW50byB0aGUgcGFnZVxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yRWFjaEluc3RhbmNlKFwiaGFuZGxlVXRpbHNcIik7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZVN1Y2Nlc3MpIGhhbmRsZVN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvckVhY2hJbnN0YW5jZShcInJlamVjdFV0aWxzU2NyaXB0UHJvbWlzZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlRmFpbHVyZSkgaGFuZGxlRmFpbHVyZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNjcmlwdC5jbGFzc05hbWUgPSBcIml0aS1sb2FkLXV0aWxzXCI7XG4gICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgc2NyaXB0LnNyYyA9IHBhdGg7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGxvYWQgdGhlIHV0aWxzIHNjcmlwdFxuICAgICAgICBpbnRsVGVsSW5wdXRHbG9iYWxzLmxvYWRVdGlscyA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIC8vIDIgb3B0aW9uczpcbiAgICAgICAgICAgIC8vIDEpIG5vdCBhbHJlYWR5IHN0YXJ0ZWQgbG9hZGluZyAoc3RhcnQpXG4gICAgICAgICAgICAvLyAyKSBhbHJlYWR5IHN0YXJ0ZWQgbG9hZGluZyAoZG8gbm90aGluZyAtIGp1c3Qgd2FpdCBmb3IgdGhlIG9ubG9hZCBjYWxsYmFjayB0byBmaXJlLCB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGhhbmRsZVV0aWxzIG9uIGFsbCBpbnN0YW5jZXMsIGludm9raW5nIHRoZWlyIHJlc29sdmVVdGlsc1NjcmlwdFByb21pc2UgZnVuY3Rpb25zKVxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuaW50bFRlbElucHV0VXRpbHMgJiYgIXdpbmRvdy5pbnRsVGVsSW5wdXRHbG9iYWxzLnN0YXJ0ZWRMb2FkaW5nVXRpbHNTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRvIHRoaXMgb25jZVxuICAgICAgICAgICAgICAgIHdpbmRvdy5pbnRsVGVsSW5wdXRHbG9iYWxzLnN0YXJ0ZWRMb2FkaW5nVXRpbHNTY3JpcHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgcHJvbWlzZXMsIHRoZW4gcmV0dXJuIGEgcHJvbWlzZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0U2NyaXB0KHBhdGgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmplY3RTY3JpcHQocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIGludGxUZWxJbnB1dEdsb2JhbHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgLy8gdmVyc2lvblxuICAgICAgICBpbnRsVGVsSW5wdXRHbG9iYWxzLnZlcnNpb24gPSBcIjE3LjAuMTNcIjtcbiAgICAgICAgLy8gY29udmVuaWVuY2Ugd3JhcHBlclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBpdGkgPSBuZXcgSXRpKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGl0aS5faW5pdCgpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiZGF0YS1pbnRsLXRlbC1pbnB1dC1pZFwiLCBpdGkuaWQpO1xuICAgICAgICAgICAgd2luZG93LmludGxUZWxJbnB1dEdsb2JhbHMuaW5zdGFuY2VzW2l0aS5pZF0gPSBpdGk7XG4gICAgICAgICAgICByZXR1cm4gaXRpO1xuICAgICAgICB9O1xuICAgIH0oKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/intl-tel-input/build/js/intlTelInput.js\n");

/***/ }),

/***/ "./node_modules/intl-tel-input/index.js":
/*!**********************************************!*\
  !*** ./node_modules/intl-tel-input/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Exposing intl-tel-input as a component\n */\nmodule.exports = __webpack_require__(/*! ./build/js/intlTelInput */ \"./node_modules/intl-tel-input/build/js/intlTelInput.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW50bC10ZWwtaW5wdXQvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EsNkhBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVFBhc3MvLi9ub2RlX21vZHVsZXMvaW50bC10ZWwtaW5wdXQvaW5kZXguanM/MDVmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4cG9zaW5nIGludGwtdGVsLWlucHV0IGFzIGEgY29tcG9uZW50XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vYnVpbGQvanMvaW50bFRlbElucHV0XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/intl-tel-input/index.js\n");

/***/ }),

/***/ "./src/styles/main.scss":
/*!******************************!*\
  !*** ./src/styles/main.scss ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL21haW4uc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9UUGFzcy8uL3NyYy9zdHlsZXMvbWFpbi5zY3NzPzUxMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles/main.scss\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	
/******/ })()
;